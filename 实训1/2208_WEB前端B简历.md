#  xxx_WEB前端B简历

## 一、自我介绍话术

```shell
⾯试官,您好, 我叫张明,今年24岁,⽬前从事前端开发有2年多的时间. 期间经历过2家公司,这两家公司都属于外包类
型的公司. 我开发过的项⽬有在线教育、医疗、养⽼、智慧园区等类型的项⽬. 我⽬前所掌握(擅⻓)技术栈有vue2、
vue3与uni-app、⼤屏可视化以及前端基础技术栈. 我最近参与开发的⼀个项⽬是智慧园区的后台项⽬. 在⼯作中我
有较强的沟通能⼒以及抗压能⼒,遇到问题能够及时有效的和领导与同学沟通. 以上就是我的⾃我介绍, 您还有什么要
了解的.
```

## 二、面试官可能会问的问题





## 三、项目介绍话术



##  四、人资可能会问的问题



## 五、vue2面试题(必须背过的) 需要补充vue父子组件生命周期执行顺序

### 5.1 vue生命周期?    (必问)

#### 1.1 什么是vue生命周期?

#### 1.2 vue生命周期都有哪些钩子函数?这些钩子函数如何触发?

#### 1.3 项目开发过程中,在生命周期里面都分别做过什么功能?

> 面试官您好,我先介绍一下什么是vue的生命周期? 所谓的vue生命周期就是vue实例从创建到销毁的整个过程我们称之为vue的生命周期,通过vue的生命周期我们可以在不同的阶段进行不同的逻辑操作.
>
>   vue生命周期常用的钩子函数一共有8个,分别是创建前后、挂载前后、更新前后以及销毁前后.   分别对应的钩子函数为beforeCreate 创建前,实例化vm,数据初始化不能使用、 created创建后,这个时候可以访问data数据,同时可以使用this、beforeMount 挂载前,diff算法进行对比阶段、mounted挂载后,dom挂载完成、beforeUpdate 更新前,新旧dom节点进行对比阶段、updated更新后,dom节点对比完成,渲染页面、beforeDestory 销毁前、 destoryed销毁后, 页面一开始加载的时候就会触发创建前后和挂载前后的钩子函数, 而更新的钩子函数需要当我们改变data的时候才能触发,比如 点击按钮,执行一个方法,在这个方式里面给data里面属性重新进行复制操作,这个时候就会更新的钩子函数, 销毁的钩子函数必须得当组件进行切换的时候就会进行销毁. 如果我们的路由是用keep-alive包裹起来的会新增两个生命周期钩子,actived(激活,进入组件会触发),deactived(失活,离开组件的时候触发).
>
> 在项目开发过程中,我经常使用到的钩子函数有created,我们经常在created进行数据请求,或者获取本地存储的数据,还有一些其他的操作.  除了created还有mounted,我们经常在mounted里面获取dom元素  (有时候也存在获取不到dom元素的情况,这个时候我们一般用$nextTick方法来解决). 以上就是我对生命周期的理解



### 5.2  vuex的理解? (必问) 

#### 2.1 什么是vuex?使用vuex能够解决什么问题?

#### 2.2 vuex的五大核心是什么?

#### 2.3 在组件里面如何调用五大核心的属性和方法?

#### 2.4 vuex的执行机制是什么?

#### 2.5 vuex的弊端是什么?怎么解决?

> 面试官您好,接下来我先给您介绍一下什么是vuex? 
>
> 所谓的vuex其实就是vue官方给我们提供的一个状态管理工具,通过vuex我们可以解决组件之间数据共享的问题.
>
>  vuex一共有5大核心,分别是state,里面保存的是状态, 接下来是getters,他们用来获取state里面的状态,并且可以对state的数据进行处理之后在返回,有点类似于vue的计算属性, 接下来还有mutations,他的作用主要是用来修改state里面的数据,不过在mutations里面只能进行同步的操作,还有actions,这个actions也可以去改变state的状态,不过在actions里面定义的方法可以进行异步操作,最后一个是modules,如果当我们的项目比较大的时候,那么保存的状态也会增加,如果都写到index.js文件里面,文件的内容就会变得特别臃肿,后期难以维护,所以我们可是使用modules进行模块化的处理,将多个状态抽离到对应js文件里面,最后在modules进行合并,这样后期就方便维护了.
>
> 接下来我在介绍一下在组件里面如何调用vuex里面的属性和方法,如果我们要获取state里面的状态,我们可以通过this.$store.state来进行获取,如果要调用getters里面的方法,我们可以通过“this.store.getter”来进行调用,如果要调用muations里面的方法我们需要使用this,$store.commit来触发,如果调用actions里面的方法,我们一般通过this.$store.dispatch来进行触发. 除了这种方式以外,我们还可以通过辅助函数的方式来进行调用和触发(mapState, mapMutation,mapAction, mapGetter)
>
> 我在项目当中如果要改变state的状态,我们一般是在组件里面调用this.$store.dispatch方式来触发actions里面的方法,在actions里面的方法通过commit来调用mutations里面定义的方法来改变state,同时这也是vuex的执行机制
>
> 不过vuex也有一些弊端,比如浏览器刷新的时候,vuex的数据会丢失,我们一般结合本地存储来解决,当我们在mutations里面改变state的时候在通过localStorage或者sessionStorage存储到本地,然后在state的状态的属性值那块写一个三元表达式,如果本地存在数据的话则读取本地存储的数据,否则就赋值为null,可是使用插件vuex-persistedstate做到本地储存
>
> 在项目当中我一般使用vuex会保存用户信息和token以及其他的一些状态. 以上就是我对vuex的理解.



### 5.3 vue路由有几种模式?有什么区别?原理是什么?(待补充,如何解决history404,官网网址),

> 面试官您好,接下来我给您介绍一下vue的路由模式,vue的路由模式一共有两种,分别是hash(哈希)和history.  他们的区别是hash模式不会包含在http请求当中,hash模式是一种把前端路由的路径用 `#`拼接在真实的URL后面的模式 当`#`后面的路径发生变化时，浏览器并不会重新发起请求，而是会触发hashchange事件。而使用history模式的话,history API 是 H5 提供的新特性，允许开发者直接更改前端路由，即`更新浏览器 URL 地址`而`不重新发起请求`(将url替换并且不刷新页面),在浏览器在刷新的时候，history会按照路径发送真实的资源请求，如果这个路径是前端通过 history API 设置的 URL，那么在服务端往往不存在这个资源，于是就返回 `404`了,这个时候往往需要后端支持,前段后请求的url都保持一致.
>
> history的原理就是利用html5新增的两个特性方法,分别是psuhState和replaceState来完成的.  以上就是我对vue路由模式的理解.

### 5.3.1 如何解决history404

> histpry模式不怕前进，不怕后退，就怕刷新 
>
> 1. 配置后端服务器：确保您的后端服务器正确配置，以支持前端路由。您需要确保后端服务器能够将所有路由请求重定向到前端应用的入口文件或者返回正确的页面。具体配置方法可能因您使用的后端框架而异，请参考相应框架的文档或向相关技术支持寻求帮助。
>
> 2. URL重写：如果您使用的是Apache或Nginx等类似的服务器，您可以尝试使用URL重写规则来处理这个问题。通过配置服务器，将所有的前端路由请求重写到特定的URL或者入口文件。例如，将所有的请求都重写到index.html文件，然后由前端应用来处理路由。具体的配置方法可以在Apache或Nginx的官方文档中找到。
>
> 3. 前端路由配置：您也可以尝试在前端应用中进行路由配置的修改。例如，您可以在路由配置中添加一个基础路径，以便在应用中的所有路由路径之前添加该基础路径。这样，在后端请求时，就可以正确匹配到相应的路由路径。
>
> 4. 联系后端开发人员：如果您无法自行解决此问题，建议与后端开发人员进行沟通，让他们检查并确认后端路径配置是否正确，并确保能够正确处理前端路由。

### 5.4 vue路由守卫?

> 面试官您好,接下来我给您介绍一下vue路由守卫,首先呢,所谓的路由守卫就是当我们进行页面跳转的时候会触发的钩子函数,我们把它称之为vue路由守卫.  vue一共给我们提供了三种路由守卫,
>
> ​	第一种全局路由守卫,全局路由守卫包含全局前置路由守卫(router.beforeEach),全局解析守卫(router.beforeResolve),全局后置守卫(router.afterEach),这几个钩子是在路由表中的,
>
> ​	第二种是组件内路由守卫,包括路由进入页面之前触发的钩子beforeRouteEnter,这个钩子里面没有this指向,想要获取组件内容,需要获取到vm进行修改内容,  beforeRouteUpdate,当前页面被重复加载渲染的时候触发的钩子,组件离开页面时候触发beforeRouteLeave.
>
>    第三种路由独享守卫,这个是写在路由里面.beforeEnter  
>
> 这几个钩子函数里面都有一个回调函数,这个回调函数里面会有三个参数,分别是to,from,next,分别对应的是要进入的路由、离开之前的路由,以及进入下一个路由
>
> 在项目中我们经常使用路由守卫实现页面的鉴权.  比如:当用户登录之后,我们会把后台返回的token以及用户信息保存到vuex和本地,当页面进行跳转的时候,我们会在路由守卫里面获取vuex里面的token,如果token存在的话,我们则使用next让他进入要跳转的页面,如果token不存在的话我们使用next方法让他回到登录页
>
> 以上就是我对vue路由守卫的理解



### 5.5  v-if与v-show的区别?(必问) (回流与重绘)

> 面试官您好,接下来我给您介绍一下v-if和v-show的区别? 首先v-if和v-show都是控制元素的显示与隐藏, 不过v-if控制元素的显示和隐藏的时候会删除对应的dom元素,当每一个显示的时候,都会重新创建dom和渲染. 而v-show则是通过动态的添加和移除css的display:none属性来控制元素的显示与隐藏. v-if比较耗费性能**,v-if隐藏dom元素后会dom元素的位置留一个注释的标识, 下次dom元素渲染时会优先查找标识点,以便节省性能** , 所以我们涉及到频繁的显示隐藏操作我们建议使用v-show,如果不是频繁操作的话,我们可以v-if
>
> 在项目中我会经常使用v-if和v-show,比如我们在搜索功能的时候,他有一个历史记录,这个时候我们根据是否有搜索的结果来判断历史记录的显示与隐藏,这块我就可以使用v-if ,当然用v-show也可以.  以上就是我对v-if和v-show的理解.



### 5.6  v-for与v-if的优先级那个高?如果同时使用v-for和v-if怎么解决?(必须) (补充vue3中v-if与v-for) 补充 vue中dom的渲染

1. **为什么不能同时使用, 如果同时使用会产生错误?  v-for包裹v-if使用会造成死循环,所有采用template模版进行包裹**

> v-for的优先级高.  因为v-for的时候我们才开始渲染dom元素,这个v-if还无法进行判断.,所以在v-for中使用v-if的时候需要用template模版上使用v-if
>
> v-for和v-if不能同时使用,我们可以通过标签,比如div或者template标签来进行包裹,把v-if写到包裹的标签上面(写到v-for外面)
>
> v-for中使用v-if不使用template包裹,会造成死循环



### 5.7  methods、computed和watch的区别? 必问 (补充项目中哪些功能用到了computed以及watch)

> 首先呢,methods是用来定义方法的区域,methods定义的方法需要调用才能触发. 不具备缓存
>
> 而computed是计算属性,他依赖于data属性值的变化而变化,当属性发生改变的时候,计算属性里面定义的方法就会触发,computed具有缓存性,依赖属性值的变化而变化.computed是同步的,computed的数据不能在data中声明
>
> 而watch主要是用于监听,不具备被缓存性.依赖于数据变化而触发. watch是异步的,可以在watch中发送请求有, 而且watch还有那个属性.,分布是deep, immeated, 其中当我们监听的数据使用引用数据类型的话, 就可以通过deep开启深度监听, immeated页面加载的时候立即开启监听
>
> 在项目中,比如我们获取state的状态的时候我们会把它放到computed里面,或者在写购物车数量计算的时候也会使用计算属性. 
>
> 而watch也在项目经常使用,比如我们封装编辑 和 新增弹窗组件的时候会通过watch来进行id判断我们要显否要清空表单的数据.
>
> 以上就是我对computed和watch的理解. 



### 5.8 vue组件通信?(必问) (单向数据流? 什么是单向数据流? 如果想在子组件内部修改props的数据,该怎么解决) 补充其他的通信方法

> 父传子  在子组件的标签上定义属性 子组件通过props来进行接受,可以通过数组的方式进行接受,也可以通过对象的方式来进行接收,如果父组件没有传递属性,子组件可以default来设置默认值, 也可以在对象里面通过required属性设置参数为必传项,
>
> 子传父	子组件通过this.$emit("自定义的事件",要传给父组件的数据),   父组件通过子组件的标签监听自定义的事件,通过方法来接收传递的数据
>
> 非父子组件通信
>
> ​	通过中央事件总线,我们也称之为eventBus,
>
> 我们需要创建一个空的js文件,在这个文件里面创建空的vue实例,然后导出这个空的vue实例,通过实例对象调用.on方法进行接收,通过emit方法来进行发送,以上就是非父子组件通信的方式



### 5.9  $nextTick方法有什么作用? (必问)  补充$nextTick实现的原理是什么? Event loop

> 1. 首先呢,$nextTick也叫做异步更新队列方法,而$nextTick方法的主要作用就是等待dom元素加载完毕之后才会执行的回调函数,我们经常会在$nextTick方法里面获取dom元素
>
> 2. 根据时间循环使用异步队列进行数据回调,并且监听dom加载时机
>
> 3. Event loop
>
>    



### 5.10  说一下什么是mvvm模式?  补充什么是mvc? (必问) mvp 

> MVVM 是把 MVC 的 Controller 和 MVP 的 Presenter 改成了 ViewModel 。
>
> View 的变化会自动更新到 ViewModel ， ViewModel 的变化也会自动同步到 View 上显示。这种自动
>
> 同步是因为 ViewModel 中的属性实现了 Observer ，当属性变更时都能触发对应的操作。
>
> https://juejin.cn/post/7073052092994158606



### 5.11  vue双向数据绑定原理?(必问)   补充有什么缺点?Object.defineProperty()有几个参数(要监听的对象,监听的属性,{get有return值,set})

> vue.js 则是采用 数据劫持 结合 发布者-订阅者 模式的方式，
>
> 通过 Object.defineProperty() 来劫持各个属性的 setter ， getter ，
>
> 通过watch监听数据变动时发布消息给订阅者，触发相应的监听回调。
>
> 这个时候就可以实现数据的双向绑定
>
> 缺点: 1. 通过下标修改数据和对象的时候,数据变了,但是视图不变
>
>         2. 每次只能监听一个属性,需要重复去监听
>
> 



### 5.12  vue常用的指令有哪些?

> v-if   			控制dom元素显示与隐藏
>
> v-show       控制dom元素显示与隐藏
>
> v-html		渲染的内容包含标签
>
> v-text	     渲染的内容不包含标签		
>
> v-on			事件绑定
>
> v-bind        属性绑定
>
> v-mode      双向数据绑定
>
> v-for		  数据循环
>
> V-pre        跳过编译
>
> V-cloak    防止白屏和闪烁





### 5.13  vue常用的修饰符有哪些?(50%).  补充.sync?

> .trim  		去除首尾多余的空格
>
> .stop			阻止事件冒泡
>
> .once		 只渲染一次
>
> .self			事件只作用在元素本身
>
> .number		将值转化为number类型
>
> .capture			组件之间捕获
>
> .prevent		阻止元素的默认行为
>
> .native			事件穿透,让我们可以在自定义组件上定义事件和方法
>
> .sync             同步任务,传值



### 5.14 vue如何封装可复用的组件?以及请举例说明你封装过的组件? 补充table、form、dialog 组件二次封装的思路(过程)

>  1. 以我常用封装的dialog为例
>   1. 入参
>       1. 弹框标题变化的参数,比如判断是新增还是修改
>      2. 如果是修改的话,传递修改信息,
>    2. 出参
>          1. 通知父组件,关闭弹框,
>       2. 返回父组件,弹框中所有信息,让父组件可以使用弹框里面的信息
>   3. 使用slot控制按钮的变化
>       1. 有的需要展示确认和取消
>      2. 有的需要展示重置等多种按钮



### 5.15  vue中key的作用是什么?(必问) 补充 为什么不优先使用index? 补充 会延伸出虚拟dom 以及 diff算法

> 避免dom元素重复渲染. 我我们一般在设置key的时候首先尽量会设置为id,或者index下标.
>
> 在虚拟DOM中key的作用：
>  key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】, 
>  随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下：
>
> 2.对比规则：
>          (1).旧虚拟DOM中找到了与新虚拟DOM相同的key：
>                      ①.若虚拟DOM中内容没变, 直接使用之前的真实DOM！
>                      ②.若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM。
>
> ​            (2).旧虚拟DOM中未找到与新虚拟DOM相同的key
> ​                        创建新的真实DOM，随后渲染到到页面。
> ​                        
> 3. 用index作为key可能会引发的问题：
>           1. 若对数据进行：逆序添加、逆序删除等破坏顺序操作:
>                           会产生没有必要的真实DOM更新 ==> 界面效果没问题, 但效率低。
>
>               2. 如果结构中还包含输入类的DOM：
>                           会产生错误DOM更新 ==> 界面有问题。
>
> 4. 开发中如何选择key?:
>           1.最好使用每条数据的唯一标识作为key, 比如id、手机号、身份证号、学号等唯一值。
>           2.如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，
>               使用index作为key是没有问题的。
>
> 5. 对比的特性
>     同节点对比
>
>     
>

### 5.16 说一下你对keep-alive的理解?以及在项目中如何使用? 补充keep-alive的原理,keep-alive 新增两个生命周期

> keep-alive是vue内置的一个组件，而这个组件的作用就是能够缓存不活动的组件，我们能够知道，一般情况下，组件进行切换的时候，默认会进行销毁，如果有需求，某个组件切换后不进行销毁，而是保存之前的状态，比如说刚刚填好的表单数据。那么就可以利用keep-alive来实现
>
> 
>
> 在搭建 vue 项目时，有某些路由组件没必要多次渲染，所以需要将组件在内存中进行‘持久化’，此时在router-view上使用keep-alive。 keep-alive可以使被包含的路由组件状态维持不变，即便是组件切换了，其内的状态依旧维持在内存之中。在下一次显示时，也不会重新渲染。
>
> include - 字符串或正则表达式。只有名称匹配的组件会被缓存。
> exclude - 字符串或正则表达式。任何名称匹配的组件都不会被缓存。
> max-数字最多可以缓存多少组件。
>
> 会新增两个生命周期,activated(激活),deactivated(失活),
>
> 以上就是我对keep-alive的理解



### 5.17  说一下什么是vue过滤器? 有几种?项目中如何使用,请举例说明?

> 所谓的vue过滤器就是将数据进行二次处理,得到我们想要的结果数据
>
> vue的过滤器分为两种,第一种是全局过滤器,通过vue.filet来进行定义,第二种是局部过滤器,需要定义在组件内部
>
> 项目中我们通过过滤器将后台返回的状态0 和1 转化为支付或者未支付 



### 5.18  说一下你对slot插槽的理解?

> 首先呢,所谓的插槽就是一个占位符,将自定义组件的内容展示出来.我们知道自定义的组件里面如果写内容的话,页面是不会显示出来的,如果我们想让自定义组件里面的内容显示出来,我们就需要使用slot的插槽. 
>
> 而插槽分别具名插槽和匿名插槽、以及作用域插槽.  我们用的比较多的具名插槽和匿名插槽,具名插槽需要所有slot标签上指定name属性,而在对应标签上添加v-slot属性.
>
> 如果我们想将插槽内部的数据传递给父组件,这个时候就需要使用作用域插槽, 
>
> 如何将数据传递到父组件. 在slot标签自定义属性, 在父组件对应的标签上通过v-slot:自定义属性=“scope”就可以进行接收
>
> 在项目中我们一般在进行组件封装的时候会使用插槽,以上就是我对插槽的理解.
>
> ```
> // 父组件
> <template>
>     <Chid>
>     		<template slot="xiaoA" slot-scope="data">
>     			{{ data }}
>     		</template>
>     </Child>
> </template>
> 
> // 子组件
> child.vue
> <template>
> 		<slot name="xiaoA" :data="data">
> 				<ul>
>             <li></li>
>         </ul>
> 		</slot>
> 
> </template>
> <script>
>     export default{
>     	 return{
>     	 	data: ['1',2,3,4,5,6,7]
>     	 }
>     }
> </script>
> ```
>
> 



### 5.19 说一下vue中本地跨域如何解决?线上跨域如何解决?(必问)   线上在讲解一下 补充同源策略 跨域是如何产生的 跨域的方式有哪些 采用代理的方式跨域的实现原理是什么

> 本地跨域   一般使用webpack,vite 是通过在vue.config.js文件里面的devServer属性里面的proxy属性里面配置,一共配置三个属性,分别是代理名称 代理地址 开启跨域 重写路径
>
> 线上跨域: nginx    是在nginx.conf文件里面配置, 代理名称是通过location 代理名称。proxy_pass 代理地址
>
> 跨域只有在浏览器上才会产生,服务器是不会有跨域产生的,当协议,ip,域名,端口号任何不同都会产生跨域
>
>    主域名和子域名?
>
>    Htttps: //www.baidu.com
>
>   https:// www.baudi.oa.com
>
> 线上解决跨域的方法: 
>
> 1. cors(后端配置4个请求头)
>
> 							2. nginx
> 							2. ifream
> 							2. Script,img  src
> 							2. Widnow.domain
> 							2. Postmessage
>
> 还有其他一些第三方配置



### 5.20 说一下如何对axios进行二次封装?以及api如何封装?(30%)

> 1. 在src文件夹内创建utils文件夹
>
> 2. 在utils文件夹内创建request.js文件
>
> 3. 在request.js内引入axios
>
> 4. 使用axios.create方法创建axios的实例,在axios.create方法里面可以配置请求的公共地址和超时时间以及其他的一些配置
>
> 5. 在创建请求拦截器和响应拦截器
>
> 6. 在请求拦截器里面可以获取vuex的token,并通过config.header.token = vuex的token,将token发送给后台
>
> 7. 在请求拦截器里面我们配置loading加载
>
> 8. 在响应拦截器里面我们可以结束loading加载以及token的过期处理,以及错误响应信息的处理
>
> 9. 最后通过export default 导出axios的实例对象
>
> 10. 在src文件内创建api文件夹
>
> 11. 在api文件夹内创建对应模块的js文件
>
> 12. 在对应的文件里面引入request.js文件
>
> 13. 封装api方法
>
> 14. 最后通过export default 导出封装的api方法



### 5.21 说一下axios的拦截器的作用?应用场景都有哪些?(80%)

> 首先呢,axios拦截器是axios给我们提供的两个方法,通过这两个方法我们可以对请求发送之前以及响应之后进行逻辑的再次处理(拦截). 这两个拦截器不需要手动触发,只要发送http请求的时候就会自动触发.
> 我在项目中经常通过拦截器发送token, 对token进行过期处理,以及进行其他的一些操作

在请求拦截器中可以通过请求头将token发送给后台, 也可以开启全局loading加载

在响应拦截器中可以对请求进行全局异常处理, 以及token 的过期处理, 关闭loading加载, 以及其他的一些操作



### 5.22  说一下vue和jquery的区别?(50%)

> 首先呢jquery他是用js封装的一个类库,主要是为了方便操作dom元素,而vue他是一个框架,并且呢,他会从真实dom构建出一个虚拟的dom树,通过diff算法渲染只发生改变的dom元素,其他的相同的dom元素不用在重新渲染. 而使用jquery去改变dom元素的时候,即使有相同的dom元素也会重新渲染,以上就是我对vue和jquery区别的理解.



### 5.23  vue中data发生变化,视图不更新如何解决?(必问) 过一下

> 面试官,您好,接下来我先给您介绍一下为什么data发生变化,视图不更新,**因为Vue实例中的数据是响应式的****而我们新增的属性并不是响应式的, Vue无法检测到属性的新增或删除。所以有时无法实时的更新到视图上。**
>
> 所以我在项目中遇到这类问题的时候一般是通过this.$set方法去解决. this.$$set方法一共有三个参数,分别是目前属性,新增属性,新增的值.
>
> 以上就是我对视图不更新的理解.



### 5.24  为什么vue中data必须是一个函数?(必问) 过一下

> 如果data是一个函数的话，这样每复用一次组件，就会返回一份新的data，类似于给每个组件实例创建一个私有的数据空间，让各个组件实例维护各自的数据。而单纯的写成对象形式，就使得所有组件实例共用了一份data，就会造成一个变了全都会变的结果。
>
> 所以说vue组件的data必须是函数。这都是因为js的特性带来的，跟vue本身设计无关。

### 5.25 vue的性能优化

>1. 减少http请求,相同接口尽量只掉一次
>
>2. 组件抽离,减少相同代码代码的重复量,减少包大小
>
>3. 图片使用懒加载和预加载进行图片优化,尽量使用svg图片
>
>4. 使用路由懒加载
>
>5. cdn加速
>
>6. seo优化
>
>7. 打包优化
>
>   1. webpack 
>
>      1. 优化webapck启动项目时间
>
>         - 如果使用 chrome 浏览器，那么在开发环境下，其实可以关闭 babel 的转义：includes: []。还有可以添加 babel 的缓存：loader: "babel-loader?cacheDirectory=true"
>
>         - 配置exclude
>
>           - exclude 是 loader 插件用来排除查找目录的，一般是 node_modules目录。exclude: /node_modules/
>
>             
>
>         - alias
>           -alias 用来简化查找路径的，一般来说一些脚手架里面会默认配置 @代表 src目录，那么我们可以根据此分别配置不同的内容，来减少一级一级查找。
>                        
>      2. 优化webpack打包速度(build后的打的包)
>                        
>         - 开启多进程打包.
>                        
>           - #### thread-loader(webpack4官方推荐)
>                        
>             ```js
>             module.exports = {
>               // ...
>               module: {
>                 rules: [
>                   {
>                     test: /\.js$/,
>                     exclude: /node_modules/,
>                     // 创建一个 js worker 池
>                     use: [ 
>                       'thread-loader',
>                       'babel-loader'
>                     ] 
>                   },
>                   {
>                     test: /\.s?css$/,
>                     exclude: /node_modules/,
>                     // 创建一个 css worker 池
>                     use: [
>                       'style-loader',
>                       'thread-loader',
>                       {
>                         loader: 'css-loader',
>                         options: {
>                           modules: true,
>                           localIdentName: '[name]__[local]--[hash:base64:5]',
>                           importLoaders: 1
>                         }
>                       },
>                       'postcss-loader'
>                     ]
>                   }
>                   // ...
>                 ]
>                 // ...
>               }
>               // ...
>             }
>             ```
>
>             
>
>           - 在webpack构建过程中，实际上耗费时间大多数用在 loader 解析转换以及代码的压缩中，HappyPack 可利用多进程对文件进行打包(默认cpu核数-1)，对多核cpu利用率更高。HappyPack 可以让 Webpack 同一时间处理多个任务，发挥多核 CPU 的能力，将任务分解给多个子进程去并发的执行，子进程处理完后，再把结果发送给主进程。
>                        
>           - 合理利用缓存,使用`cache-loader`，`HardSourceWebpackPlugin` 或 `babel-loader` 的 `cacheDirectory` 标志
>                        
>           - 优化压缩时间
>
>8. 合理利用缓存,强缓存和协商缓存



### 5.26 浏览器本地储存有哪些方法?localStorage和sessionStorage的区别和相同点?session和cookie的区别和相同点?

>1. Cookie：在html5没有出现之前,我们浏览器存储数据的⽅式⼀般都是采⽤cookie,cookie具有`过期时间`,到达指定的时间cookie就会消失,并且⼀个域名下最多只能存储20条cookie,并且cookie的⼤⼩有⼀定的限制,最后可`存储4kb`，cookie会参与到与服务端的通信中，一般会`携带在http请求的头部中`，例如一些关键密匙验证等。
>
>2. localStorage和sessionStorage: ⽽localstorage和sessionstorage都是html5新增的两个api⽅法,localStorage和sessionStorage是单纯的前端存储，`不参与与服务端的通信`，localstroage也称之为数据持久化,当我们使⽤localstorage将数据存储到本地的时候,如果不在浏览器上⼿动清楚或者不调⽤clear或者removeitem⽅法他是不会⾃动清楚的.
>     ⽽sessionstorage我们称之为会话存储,使⽤sessionstorage存储的数据再关闭当前⻚⾯之后就会消失
>
>   ​        两者一旦储存起来,刷新页面就不会丢失,而且localStorage在次打开上一次会话才能看到储存的信息,打开新的会话机制是获取不到之前的信息的
>
>3. IndexedDB:IndexedDB是一种内置的客户端数据库，用于在浏览器中存储结构化数据。它通过键值对的形式存储数据，并提供了强大的查询功能。IndexedDB适用于存储大量数据或需要离线访问的应用程序
>
>4. session和cookie: session是储存在服务端的无状态的数据,不存在泄露问题,但是每个session都一个session_id,session_id是储存在cookie中的

### 5.27 vue打包线上包和线下包有什么区别

>打包 : nup run  build
>
>线上打包的提交比较小, 将js,css,img,fonts单独打成各自文件夹,并且实现代码压缩,打包后的体积比线下环境小
>
>线下打包,体积比较大,只压缩js文件,不会生成css,fonts,img等文件夹
>
> 通过--mode指定打包环境,当没有指定的时候,是线上包



### 5.28 父组组件,对子组件使用v-if,v-if从true到false经历了那些生命周期,从false到true经历了那些生命周期

>1. 从false到true,先执行父组件的beforeUpdate,在执行子组件的beforeCreate,create, beforeMoun,mounted,在执行父组件的updated生命周期
>2. 从true到false,先执行父组件beforeUpdate,在执行子组件的beforeDestroy,destroyed,在执行父组件的updated
>
>如果只是组件内部dom元素的切换,只会触发beforeUpdate和updated两个生命周期

### 5.29 v-show从true到false经历那些生命周期,从false到true经历那些生命周期     <重点>

>1. false到true
>   1. beforeUpdate->update
>2. True-->false
>   1. beforeUpdate->update
>
>

### 5.30父子组件执行的生命周期顺序

>1. 组件挂载
>
>   先执行父组件beforeCreate, created,beforeMount,在执行子组件beforeCreate,created,beforeMount,mounted生命周期,最后在执行父组mounted生命周期
>
>2. 组件更新
>
>   先执行父组件的beforeUpdate,在执行子组件的 beforeUpdate,updated,最后执行父组件updated



### 5.31 vueDom渲染是异步渲染还是同步渲染

>dom渲染是异步的,因为diff算法节点对比是异步的,所以对应的dom渲染是异步的

### 5.32 说说你对vue的mixin的理解，有什么应用场景？

>​        `mixin`（混入），提供了一种非常灵活的方式，来分发 `Vue` 组件中的可复用功能,本质其实就是一个`js`对象，它可以包含我们组件中任意功能选项，如`data`、`components`、`methods`、`created`、`computed`等等,混入分为局部混入和全局混入两种混入方式
>
>​		需要我们注意的是,当组件存在与`mixin`对象相同的选项的时候，进行递归合并的时候组件的选项会覆盖`mixin`的选项
>
>但是如果相同选项为生命周期钩子的时候，会合并成一个数组，先执行`mixin`的钩子，再执行组件的钩子      
>
>​		应用场景:比如我们每个页面都有表格页面,都需要请求list接口,然后就可以获取封装都minix中,进行全部的调用和封装节约代码

### 5.34 什么是虚拟DOM,虚拟DOM和真实DOM的区别?

>​       实际上它只是一层对真实`DOM`的抽象，以`JavaScript` 对象 (`VNode` 节点) 作为基础的树，用对象的属性来描述节点，最终可以通过一系列操作使这棵树映射到真实环境上,创建虚拟`DOM`就是为了更好将虚拟的节点渲染到页面视图中，所以虚拟`DOM`对象的节点与真实`DOM`的属性一一照应.虚拟DOM不包含真实DOM上的各种节点和属性,
>
>  真实DOM包含各种节点的属性和方法
>
>

### 5.35 SPA首屏加载速度慢的怎么解决

>​        首屏加载是指: 指的是浏览器从响应用户输入网址地址，到首屏内容渲染完成的时间，此时整个网页不一定要全部渲染完成，但需要展示当前视窗需要的内容,首屏加载可以说是用户体验中**最重要**的环节
>
>2. 首屏加载慢的原因是
>   - 网络延时问题
>   - 资源文件体积是否过大
>   - 资源是否重复发送请求去加载了
>   - 加载脚本的时候，渲染内容堵塞了
>3. 解决首屏加载的方法可以从一下方法解决
>   - 减小入口文件积
>   - 静态资源本地缓存
>   - UI框架按需加载
>   - 图片资源的压缩
>   - 组件重复打包
>   - 开启GZip压缩
>   - 使用SSR

### 5.36 了解过SSR吗?SSR解决了什么问题？有做过SSR吗？你是怎么做的？

>​       SSR意为服务端渲染,后端渲染出完整的首屏的`dom`结构返回，前端拿到的内容包括首屏及完整`spa`结构，应用激活后依然按照`spa`方式运行
>
>SSR主要解决了以下两种问题：
>
>- seo：搜索引擎优先爬取页面`HTML`结构，使用`ssr`时，服务端已经生成了和业务想关联的`HTML`，有利于`seo`
>- 首屏呈现渲染：用户无需等待页面所有`js`加载完成就可以看到页面视图（压力来到了服务器，所以需要权衡哪些用服务端渲染，哪些交给客户端）

### 5.37 什么是SPA?MPA和SPA有什么区别?或者 什么是单页面应用,多页面应用和单页面应用相比有什么相同点和不同点

> ​        SPA是指单页页应用,是只加载一个单独网页的 web 应用实现,这使得用户在访问网站时无需加载新的页面，可以获得性能提升和动态的体验，但会相应地丧失诸如 SEO（搜索引擎优化）的优势，同时需要更多精力维护状态、实现导航以及做一些有意义的性能监控。	
>
> ​      MPA是多页面应用,每个页面都是一个主页面，当我们在访问另一个页面的时候，都需要重新加载`html`、`css`、`js`文件.
>
> #### 单页应用优缺点
>
> 优点：
>
> - 具有桌面应用的即时性、网站的可移植性和可访问性
> - 用户体验好、快，内容的改变不需要重新加载整个页面
> - 良好的前后端分离，分工更明确
>
> 缺点：
>
> - 不利于搜索引擎的抓取
> - 首次渲染速度相对较慢

## 六、vue3面试题(必须背过的)

### 6.1 v3和v2相比有什么优势,v2和v3的区别?

>- vue 最主要的特点就是响应式机制、模板、以及对象式的组件声明语法，而 3.0 对这三部分都做了更改。
>  1. 性能的提升
>     - 打包大小减少41%
>
>     - 初次渲染快55%, 更新渲染快133%
>
>     - 内存减少54%
>  2. 源码的升级
>     * 使用Proxy代替defineProperty实现响应式
>     * diff算法的优化
>  3. 更好的ts支持
>  4. 更多新的功能
>     * Composition API（组合API）代替 vue2是选项式API
>     * 函数式编程思维,使用函数编程
>  5. hooks思想的引入

### 6.2 Vue3.0里为什么要用 Proxy API 替代 defineProperty API 或者 v2的双向绑定和v3双向绑定有什么区别?

>​        vue2的响应式通过```Object.defineProperty()```对属性的读取、修改进行拦截（数据劫持）,一次只能监听对象的一个属性,想要监听全部对象,需要循环多个产出多个Object.defineProperty(),对性能浪费特别大.当我们通过下标修改数组的时候,会出现数据变了,但是视图不更新的问题,对象深层次的修改也监听不到.
>
>​      v3通过es6新增的proxy实现代理,通过Proxy（代理）:  拦截对象中任意属性的变化, 包括：属性值的读写、属性的添加、属性的删除等,在proxy内部调用,Reflect（反射）:  对源对象的属性进行操作。一次监听所有对象,可以深度监听对象,不会出现数据变了视图不更新,同时节约了性能



### 6.3 说说reactive对比ref

>-  从定义数据角度对比：
>   -  ref用来定义：<strong style="color:#DD5145">基本类型数据</strong>。
>   -  reactive用来定义：<strong style="color:#DD5145">对象（或数组）类型数据</strong>。
>   -  备注：ref也可以用来定义<strong style="color:#DD5145">对象（或数组）类型数据</strong>, 它内部会自动通过```reactive```转为<strong style="color:#DD5145">代理对象</strong>。
>-  从原理角度对比：
>   -  ref通过``Object.defineProperty()``的```get```与```set```来实现响应式（数据劫持）。
>   -  reactive通过使用<strong style="color:#DD5145">Proxy</strong>来实现响应式（数据劫持）, 并通过<strong style="color:#DD5145">Reflect</strong>操作<strong style="color:orange">源对象</strong>内部的数据。
>-  从使用角度对比：
>   -  ref定义的数据：操作数据<strong style="color:#DD5145">需要</strong>```.value```，读取数据时模板中直接读取<strong style="color:#DD5145">不需要</strong>```.value```。
>   -  reactive定义的数据：操作数据与读取数据：<strong style="color:#DD5145">均不需要</strong>```.value```。

### 6.4 说一说你对setup的理解

>- setup执行的时机
>  - 在beforeCreate之前执行一次，this是undefined。
>  - 替代了两个生命周期  beforeCreate  created 生命周期
>  - 执行一次
>  - 高阶函数调用的时候执行两次(父子)
>
>- setup的参数
>  - props：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性。
>  - context：上下文对象
>    - attrs: 值为对象，包含：组件外部传递过来，但没有在props配置中声明的属性, 相当于 ```this.$attrs```。
>    - slots: 收到的插槽内容, 相当于 ```this.$slots```。
>    - emit: 分发自定义事件的函数, 相当于 ```this.$emit```。
>
>- 传递props的时候和emit的时候需要申明一下

### 6.5 说一说v3中**watch 和 watchEffect 的区别？**

>watch和watchEffect都是监听函数,
>
>watch只能监听一个数据,只有在数据变化了的时候才会执行,可以返回新值和就值,可以配置deep和immediate属性
>
>watchEffect则是页面一加载就是执行,在函数中声明那个属性,就会监听那个属性,但是只会返回最新的值



### 6.6 说一下v3的生命周期变化

>- Vue3.0中可以继续使用Vue2.x中的生命周期钩子，但有有两个被更名：
>  - ``beforeDestroy```改名为 ```beforeUnmount```
>  - ```destroyed```改名为 ```unmounted```  
>
>- Vue3.0也提供了 Composition API 形式的生命周期钩子，与Vue2.x中钩子对应关系如下：
>  - `beforeCreate`===>`setup()`
>  - `created`=======>`setup()`
>  - `beforeMount` ===>`onBeforeMount`
>  - `mounted`=======>`onMounted`
>  - `beforeUpdate`===>`onBeforeUpdate`
>  - `updated` =======>`onUpdated`
>  - `beforeUnmount` ==>`onBeforeUnmount`
>  - `unmounted` =====>`onUnmounted`
>
>- 总结:
>
>  - 组合式生命周期要比配置项快一点

### 6.7 说一说Composition API 的优势在哪里?

>​       使用传统OptionsAPI中，新增或者修改一个需求，就需要分别在data，methods，computed里修改 。在vue2中,所有功能和模块的代码全部融合在一起,如果一个地方,就要去修改整页代码,会造成不可预估的bug,产生许多额外的工作,花费大量的时间去阅读和查阅代码
>
>​     我们可以更加优雅的组织我们的代码，函数。让相关功能的代码更加有序的组织在一起。
>
>​      所有代码分模块存放,每个功能都放在自己的函数内部,想要修改某个功能,修改一个函数或者一个组件即可,节约成本,较少耦合



### 6.8 v3的diff算法做了那些优化

>`vue3`在`diff`算法中相比`vue2`增加了`静态标记`，其作用是为了会发生变化的地方添加一个`flag标记`，下次发生变化的时候`直接`找该地方进行比较。

### 6.9 说一说pina和vuex的区别或者pina的优势在哪里

>[Pinia](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fvuejs%2Fpinia) 是 `Vue` 官方团队成员专门开发的一个全新状态管理库，并且 `Vue` 的官方状态管理库已经更改为了 `Pinia`。在 [Vuex](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fvuejs%2Fvuex) 官方仓库中也介绍说可以把 `Pinia` 当成是不同名称的 `Vuex 5`，这也意味不会再出 `5` 版本了。
>
>优点
>
>- 更加轻量级，压缩后提交只有`1.6kb`。
>- 完整的 `TS` 的支持，`Pinia` 源码完全由 `TS` 编码完成。
>- 移除 `mutations`，只剩下 `state` 、 `actions` 、 `getters` 。
>- 没有了像 `Vuex` 那样的模块镶嵌结构，它只有 `store` 概念，并支持多个 `store`，且都是互相独立隔离的。当然，你也可以手动从一个模块中导入另一个模块，来实现模块的镶嵌结构。
>- 无需手动添加每个 `store`，它的模块默认情况下创建就自动注册。
>- 支持服务端渲染（`SSR`）。
>- 支持 `Vue DevTools`。
>
>> `Pinia` 配套有个插件 [pinia-plugin-persist](https://link.juejin.cn/?target=https%3A%2F%2Fseb-l.github.io%2Fpinia-plugin-persist%2F)进行数据持久化，否则一刷新就会造成数据丢失

### 6.10 v3的组件通信和v2的组件通信有什么区别

>Vue3通信方式：
>
>- props
>- $emit
>- expose / ref
>- $attrs
>- v-model
>- provide / inject（原理：原型链）
>- Vuex/pinia
>
>Vue2.x 组件通信共有12种
>
>- props
>- $emit / v-on
>- .sync
>- v-model
>- ref
>- children/children / children/parent
>- attrs/attrs / attrs/listeners
>- provide / inject
>- EventBus
>- Vuex
>- $root
>- slot

### 6.10 v3新增那些特性

>1. ref
>2. reactive
>3. watch 
>4. watchEffect
>5. project/inject
>6. Fragment---虚拟根节点
>7. 自定义hook
>
>

## 七、Ts面试题(必须背过的)

### 7.1 说说你对 TypeScript 的理解？与 JavaScript 的区别？

>​    `TypeScript` 是 `JavaScript` 的类型的超集，支持`ES6`语法，支持面向对象编程的概念，如类、接口、继承、泛型等
>
>​      ts是在代码编译过程中对代码进行类型校验,而js则是在代码运行的时候才能捕捉错误,js是一门弱类型的语言
>
>​      其是一种ts是静态类型检查的语言，提供了类型注解，在代码编译阶段就可以检查出数据类型的错误,同时扩展了`JavaScript` 的语法，所以任何现有的`JavaScript` 程序可以不加改变的在 `TypeScript` 下工作,为了保证兼容性，`TypeScript` 在编译阶段需要编译器编译成纯 `JavaScript` 来运行，是为大型应用之开发而设计的语言

### 7.2 说说 typescript 的数据类型有哪些？

>- boolean（布尔类型）
>- number（数字类型）
>- string（字符串类型）
>- array（数组类型）
>- tuple（元组类型）
>- enum（枚举类型）
>- any（任意类型）
>- null 和 undefined 类型
>- void 类型
>- never 类型
>- object 对象类型

### 7.3 说说你对 TypeScript 中枚举类型的理解？应用场景？

>​        枚举是一个被命名的整型常数的集合，用于声明一组命名的常数,当一个变量有几种可能的取值时,可以将它定义为枚举类型,通俗来说，枚举就是一个对象的所有可能取值的集合
>
>​      枚举用enum表示
>
>​     常应用于规定状态变化和网络状态码的封装,消灭代码中的魔法数字

### 7.4 说说你对 TypeScript 中接口的理解？应用场景？

>接口是用interface声明,常用来定义对象的类型校验,使用对象的时候可以定义
>
>接口可以继承,用extend实现两个接口继承
>
>接口命名重复,两个接口将会合并

### 7.5说说你对 TypeScript 中类型别名的理解？应用场景？

>类型别名，为类型创建一个新名称。它并不是一个类型，只是一个别名。
>
>可以定义基本类型,联合类型,元组类型

###  7.6 类型别名和接口定义的相同点和不同点

>1、如果需要被 extends 或者 implements, 则尽量使用**接口**。
>
>2、如果需要使用联合类型(|)或者元组类型，**类型别名**会更合适。
>
>3、如果是定义对象或函数，则都可以。
>
>4、如果实在不想选择的话，就能用interface实现，用interface，如果不能就用type。
>
>1. . **相同点**
>
>1. 都可以描述一个对象或者函数
>
>2. 都允许继承(官网话叫拓展 extends)
>
>   interface 和 type 都可以拓展，并且两者并不是相互独立的，也就是说 interface 可以 extends type, type 也可以 extends interface 。 虽然效果差不多，但是两者语法不同。
>
>   1. 接口和接口继承使用 extends继承
>
>2. 不同点
>
>    type不能重复定义,interface只能定义对象,其他的类型不能定义,但是type可以

### 7.7 说说对 TypeScript 中命名空间与模块的理解？区别？

>命名空间一个最明确的目的就是解决重名问题
>
>开启命名空间使用: namespace

### 7.7 说一说ts中的交叉类型,联合类型,可选属性?

>- 交叉类型 & 
>- 联合类型 |
>- 可选属性 ?
>

### 7.8 **TypeScript中never和void的区别？**

>* void 表示没有任何类型（可以被赋值为 null 和 undefined）。
>
>* never 表示⼀个不包含值的类型，即表示永远不存在的值。
>
>* 拥有 void 返回值类型的函数能正常运⾏。拥有 never 返回值类型的函数⽆法正常返回，⽆法终⽌，或会抛出异常。

### 7.9 TS中any和unknown有什么区别？

>​        unknown 和 any 的主要区别是 unknown 类型会更加严格：在对 unknown 类型的值执⾏⼤多数操作之前，我们必须进⾏某种形式的检查。⽽在对 any 类型的值执⾏操作之前，我们不必进⾏任何检查。
>
>**总结**: any 和 unknown 都是顶级类型，但是 unknown 更加严格，不像 any 那样不做类型检查，反⽽unknown 因为未知性质，不允许访问属性，不允许赋值给其他有明确类型的变量。

### 7.10 tsconfig.json有什么作⽤

>tsconfig.json是ts编译器的配置⽂件，ts可以根据它的信息来对待吗进⾏编译 可以再tsconfig中写注释
>
>在tsconfig.json⽂件中，可以指定不同的选项来告诉编译器如何编译当前项⽬。
>
>⽬录中包含tsconfig.json⽂件，表明该⽬录是TypeScript项⽬的根⽬录。
>
>```js
>"include":[
> // ** : 任意⽬录 ， * : 任意⽂件
> "./src/**/*"
> ],
> "exclude": [
> "./src/hello/**/*"
> ],
> // "extends": "./configs/base",
> "files": [
> "1.ts",
> // "2.ts"
> ],
> "compilerOptions": {
> // ⽤来指定 ES 版本 ESNext : 最新版。 'ES3', 'ES5', 'ES6'/'ES2015',
>'ES2016', 'ES2017', 'ES2018', 'ES2019', 'ES2020', 'ESNext'
> "target": "ES2020",
> // 指定要使⽤模块化的规范 : 'None', 'CommonJS', 'AMD', 'System', 'UMD',
>'ES6'/'ES2015', 'ES2020' or 'ESNext'
> "module": "ESNext",
> // ⽤来指定项⽬中要使⽤的库 'ES5', 'ES6', 'ES2015', 'ES7', 'ES2016',
>'ES2017', 'ES2018', 'ESNext', 'DOM', 'DOM.Iterable',
> // 'WebWorker', 'ScriptHost', 'ES2015.Core',
>'ES2015.Collection', 'ES2015.Generator', 'ES2015.Iterable',
> // 'ES2015.Promise', 'ES2015.Proxy',
>'ES2015.Reflect', 'ES2015.Symbol', 'ES2015.Symbol.WellKnown',
> // 'ES2016.Array.Include', 'ES2017.object',
>'ES2017.Intl', 'ES2017.SharedMemory', 'ES2017.String',
> // 'ES2017.TypedArrays', 'ES2018.Intl',
>'ES2018.Promise', 'ES2018.RegExp', 'ESNext.AsyncIterable',
> // 'ESNext.Array', 'ESNext.Intl',
>'ESNext.Symbol'
> // 运⾏在浏览器中不⽤设置，运⾏在node或其他中才需要设置
> // "lib":[]，
> // ⽤来指定编译后⽂件的存放位置
> "outDir":"./dist",
> // 将代码合并为⼀个⽂件,设置之后所有的全局作⽤域中的代码会合并到同⼀个⽂件中 但是只
>能在 'amd' and 'system' 中才能使⽤
> // "outFile": "./dist/app.js",
> // 是否对js⽂件进⾏编译，默认false
> "allowJs": false,
> // 是否检查js代码是否符合语法规范，默认false
> "checkJs": false,
> // 是否移除注释，默认false
> "removeComments":false,
> // 是否不⽣成编译后⽂件，默认false
> "noEmit": false,
> // 当有错误时是否⽣成⽂件，默认false
> "noEmitOnError": false,
> // 是否⽣成sourceMap，默认false 这个⽂件⾥保存的，是转换后代码的位置，和对应的转
>换前的位置。有了它，出错的时候，通过断点⼯具可以直接显示原始代码，⽽不是转换后的代码。
> "sourceMap":false,
> // 所有的严格检查的总开关，默认false
> "strict": false,
> // 编译后的⽂件是否开启严格模式，默认false
> "alwaysStrict": false,
> // 不允许隐式的any，默认false(允许)
> "noImplicitAny": false,
> // 不允许隐式的this，默认false(允许)
> "noImplicitThis": false,
> // 是否严格的检查空值，默认false 检查有可能为null的地⽅
> "strictNullChecks": true,
> // 是否严格检查bind、call和apply的参数列表，默认false 检查是否有多余参数
> "strictBindCallApply":false,
> // 是否严格检查函数的类型，
> "strictFunctionTypes":false,
> // 是否严格检查属性是否初始化，默认false
> "strictPropertyInitialization":false,
> // 是否检查switch语句包含正确的break，默认false
> "noFallthroughCasesInSwitch":false,
> // 检查函数没有隐式的返回值，默认false
> "noImplicitReturns":false,
> // 是否检查检查未使⽤的局部变量，默认false
> "noUnusedLocals":false,
> // 是否检查未使⽤的参数，默认false
> "noUnusedParameters":false,
> // 是否检查不可达代码报错，默认false true，忽略不可达代码 false，不可达代码将引
>起错误
> "allowUnreachableCode":false
> }
>}
>```

### 7.11 TS中的泛型是什么？

>TypeScript Generics是提供创建可重⽤组件的⽅法的⼯具。 它能够创建可以使⽤多种数据类型⽽不
>
>是单⼀数据类型的组件。 ⽽且，它在不影响性能或⽣产率的情况下提供了类型安全性。 泛型允许我们创
>
>建泛型类，泛型函数，泛型⽅法和泛型接⼝。
>
>在泛型中，类型参数写在左括号（<）和右括号（\>）之间，这使它成为强类型集合。 它使⽤⼀种特殊的
>
>类型变量来表示类型



## 八、ES6面试题(必须背过的)

### 8.1 说说var、let、const之间的区别

>var 具有变量提升和变量覆盖的情况
>
>let和const,`ES6`新增的命令，用来声明变量,用法类似于`var`，但是所声明的变量，只在`let`和const 命令所在的代码块内有效
>
>Let 声明的变量可以修改
>
>const 一般声明的是常量,一般不能修改,但是声明的数组和对象却可以修改,因为对象和数组放在堆中,指针并没有变
>
>在es6之前只有全局作用域和函数作用域,在es6以后才有了块级作用域

### 8.2 es6新增了那些属性?

>​         新增了let  const  class promise, Map,Set,proxy,async和await,以及一些对象和数组的方法,扩展运算符常用的就这些,不常用的有类似于Generator函数,遍历器,生成函数,这些大概了解过

### 8.3 你是怎么理解ES6中 Promise的？使用场景？

#### Promise出现的原因,有哪些方法,概念

>​         promise函数是解决异步编程问题产生的,所谓`Promise`，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理
>
>​         promise 对象的状态不受外界影响,有三种状态：`pending`（进行中）、`fulfilled`（已成功）和`rejected`（已失败）,其中一旦状态改变,就不会再变,任何时候都可以得到这个结果.`Promise`对象的状态改变，只有两种可能：从`pending`变为`fulfilled`和从`pending`变为`rejected`。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对`Promise`对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。
>
>​        `Promise`构建出来的实例存在以下方法, .then() .catch().finally(),其中then可以链式调用,上一个then用return返回值后,下一个then即可获取到上一个接口的返回值
>
>​         常用的promise有all,race,resolve,reject方法,其中all和race都接受一个数组作为参数,all是全部函数返回成功,才会生成一个数组获取返回的内容,但凡其中有一个请求失败,将会走catch方法,race是那个接口请求的快,就以那个接口的状态作为最终的状态.resolve方法是成功返回,reject是失败的返回



### 8.4 说一说你对async和await的理解

>​        `async/await`从字面意思上很好理解，`async`是异步的意思，`await`有等待的意思，而两者的用法上也是如此。`async`用于申明一个`function`是异步的，而`await` 用于等待一个异步方法执行完成。async和await需要用try,catch处理错误信息
>
>​       async和await是根据Generator函数封装而来的,但是他对promise的链式调用复杂逻辑处理有很好的解决办法,当我们使用promise链式调用的方法特别复杂的情况下,就可以使用async和await函数去处理

### 8.5 你是怎么理解ES6新增Set、Map两种数据结构的？

>- Set 和 Map 主要的应用场景在于 数据重组 和 数据储存。
>
>- Set 是一种叫做集合的数据结构，Map 是一种叫做字典的数据结构。
>
>- 什么是集合？什么又是字典？
>
>  - 集合
>    是由一堆无序的、相关联的，且不重复的内存结构【数学中称为元素】组成的组合
>  - 字典
>    是一些元素的集合。每个元素有一个称作key 的域，不同元素的key 各不相同
>
>  区别？
>
>  - 共同点：集合、字典都可以存储不重复的值
>  - 不同点：集合是以[值，值]的形式存储元素，字典是以[键，值]的形式存储

### 8.6 ES6中数组新增了哪些扩展？

### 8.7对象新增了哪些扩展？

### 8.8 说一说箭头函数?

>1. this是动态的, `this`的值取决于函数本身被谁调用
>2. 没有arguments伪数组,如果有绝对是来自于父组件
>3. 不能作为构造实例化对象
>
>

### 8.9 说一下proxy对象

>**Proxy** 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）,有两个参数`target`表示所要拦截的目标对象（任何类型的对象，包括原生数组，函数，甚至另一个代理））,`handler`通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 `p` 的行为,proxy可以一次监听整个对象,并且在proxy内部借用了Reflect来实现对对象的新增,修改和删除.v3中的双向数据代理就采用proxy对象.
>
>   proxy可以深度监听对象,并且代理整个对象,节约了性能
>
>

## 九、Js面试题(必须背过的)

### 9.1 说一说promise函数

>​       Promise是异步编程的一种解决方案，它是一个对象，可以获取异步操作的消息，他的出现大大改善了异步编程的困境，避免了地狱回调，它比传统的解决方案回调函数和事件更合理和更强大。promise本身只是一个容器,真正异步的是它的两个回调resolve()和reject(),promise本质 不是控制 异步代码的执行顺序（无法控制） ， 而是控制异步代码结果处理的顺序
>
>​      Promise的实例有**三个状态**:Pending（进行中）,Resolved（已完成）,Rejected（已拒绝）,当把一件事情交给promise时，它的状态就是Pending，任务完成了状态就变成了Resolved、没有完成失败了就变成了Rejected。
>
>​      promise的状态变化只有两种,一种从 pending 就会变为 resolved,一种是从 pending 就会变为 rejected,旦从进行状态变成为其他状态就永远不能更改状态了。
>
>​    Promise的实力方法有,then,catch,finally,all,race等方法,其中then 是成功,catch是报错,all是并发请求,可以同时请求多个接口,接收参数是一个数组,所有函数都返回成功才会返回,返回值是一个数组,其中但凡有一个方法返回失败,就都返回失败,
>
>​    race也是接收一个数组,但是以优先返回结果的状态为结果,
>
>​    finally是无论成功和失败都是返回  

### 9.2 Event Loop

>因为JS是单线程的，即同一时间只能执行一个任务
>
>在JS中，任务分为同步任务和异步任务,同步任务：在主线程上执行的，形成一个执行栈，前一个任务执行完后执行后一个任务,比如for循环，事件绑定，Dom...
>
>异步任务：通过回调函数实现在做任务的同时还能做其他任务
>
>- 比如定时器的回调，ajax的回调，事件函数
>
>- 异步任务又分为宏任务和微任务
>  - 宏任务：setTimeout，setInterval，ajax，dom事件监听...
>  - 微任务：.then，async/await...
>
>优先执行同步任务，遇到异步任务推入任务队列中，等同步任务执行完再执行任务队列中的异步任务，异步任务中又分宏任务和微任务，先执行微任务，再执行宏任务

### 9.3 说一说防抖和节流,和他的应用场景

>​        防抖是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。**（防抖函数内心独白：“你就抖动吧！等你不抖动了，我们在进行下一步”）**
>
>​       节流是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。**(形象的的说就是：no！no！no！一个一个来，按照时间节奏来！插队禁止！)  **
>
>应用场景: 
>
>防抖
>
>- 表单输入：当用户连续输入时，可以使用防抖来延迟处理用户输入的操作，以减少频繁的请求或操作。
>- 按钮点击：当用户快速点击按钮时，可以使用防抖来确保只执行最后一次点击操作，避免不必要的多次触发。
>- 窗口大小改变：当窗口大小改变时，可以使用防抖来延迟重新计算布局或重新渲染页面，避免过多的计算和重绘。
>
>节流
>
>- 滚动事件：当用户滚动页面时，可以使用节流来控制事件处理的频率，避免过多的计算和渲染开销。
>- 鼠标移动事件：当用户移动鼠标时，可以使用节流来减少鼠标移动事件的触发次数，以提高页面性能。
>- 无限加载：当用户滚动到页面底部时，可以使用节流来控制触发加载更多数据的频率，避免一次性加载大量数据

### 9.4 说一说原型和原型链以及继承的方法

>​          **  原型链是一种查找规则**,当访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，这种链式查找过程称之为原型链,原型链的尽头是null。也就是**Object.prototype.\**proto\****.
>
>​       其实一切对象都是继承自`Object`对象，`Object` 对象直接继承根源对象`null`,一切的函数对象（包括 `Object` 对象），都是继承自 `Function` 对象,`Object` 对象直接继承自 `Function` 对象.`Function`对象的`__proto__`会指向自己的原型对象，最终还是继承自`Object`对象
>
>2. 继承的方法
>
>1.原型链继承
>
>**关键：子类构造函数的原型为父类构造函数的实例对象**
>
>**缺点**：1、子类构造函数无法向父类构造函数传参。
>
>　　　2、所有的子类实例共享着一个原型对象，一旦原型对象的属性发生改变，所有子类的实例对象都会收影响
>
>　　　3、如果要给子类的原型上添加方法，必须放在Son.prototype = new Father()语句后面
>
>2.借用构造函数继承
>
>**关键：用 .call() 和 .apply()方法,在子类构造函数中,调用父类构造函数**
>
>**缺点**：1、只继承了父类构造函数的属性，没有继承父类原型的属性。
>
>　　　2、无法实现函数复用，如果父类构造函数里面有一个方法，会导致每一个子类实例上面都有相同的方法。
>
>3.组合继承
>
>**关键：原型链继承+借用构造函数继承**
>
>**缺点**：1、使用组合继承时，父类构造函数会被调用两次，子类实例对象与子类的原型上会有相同的方法与属性，浪费内存。
>
>4.原型式继承
>
>**关键：创建一个函数，将要继承的对象通过参数传递给这个函数，最终返回一个对象，它的隐式原型指向传入的对象。** (***Object.create()方法的底层就是原型式继承***)
>
>**缺点**：只能继承父类函数原型对象上的属性和方法，无法给父类构造函数传参
>
>5.寄生式继承
>
>**关键：在原型式继承的函数里，给继承的对象上添加属性和方法，增强这个对象**
>
>**缺点**：只能继承父类函数原型对象上的属性和方法，无法给父类构造函数传参
>
>6.寄生组合继承
>
>**关键：原型式继承 + 构造函数继承**
>
>**Js最佳的继承方式，只调用了一次父类构造函数**
>
>7.混入继承
>
>**关键：利用Object.assign的方法多个父类函数的原型拷贝给子类原型**
>
>8. class继承
>
>**关键：class里的extends和super关键字，继承效果与寄生组合继承一样**

### 9.5 说说你对浅拷贝和深拷贝的理解

>浅拷贝：
>
>- 浅拷贝，指的是创建新的数据，这个数据有着原始数据属性值的一份精确拷贝
>- 如果属性是基本类型，拷贝的就是基本类型的值。如果属性是引用类型，拷贝的就是内存地址
>- 即浅拷贝是拷贝一层，深层次的引用类型则共享内存地址
>
>常见的浅拷贝：
>
>- Object.assign
>- Object.create
>- slice
>- concat()
>- 展开运算符
>
>**深拷贝**
>
>深拷贝开辟一个新的栈，两个对象属完成相同，但是对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性
>
>常见的深拷贝方式有：
>
>- _.cloneDeep()。loadsh
>- jQuery.extend()
>- JSON.stringify().JSON.parse(), 但是如果包含函数做不到深拷贝
>- 手写循环递归



### 9.6 说说JavaScript中的数据类型？存储上的差别？

>JavaScript共有八种数据类型
>
>基本数据类型： Undefined、Null、Boolean、Number、String、Symbol、BigInt。
>
>引用数据类型：object,function,array
>
>其中 Symbol 和 BigInt 是ES6 中新增的数据类型：
>
>- Symbol 代表创建后独一无二且不可变的数据类型，它主要是为了解决可能出现的全局变量冲突的问题。
>- BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。
>
>基本数据类型存储在栈中
>
>引用类型的对象存储于堆中

### 9.7  说一说数据类型检测的方式有哪些

>然后判断数据类型的方法一般可以通过：**typeof**、**instanceof**、**constructor**、**toString**四种常用方法
>
>| 不同类型的优缺点 | typeof                                                     | instanceof                         | constructor                                 | Object.prototype.toString.call   |
>| ---------------- | ---------------------------------------------------------- | ---------------------------------- | ------------------------------------------- | -------------------------------- |
>| 优点             | 使用简单                                                   | 能检测出`引用类型`                 | 基本能检测所有的类型（除了null和undefined） | 检测出所有的类型                 |
>| 缺点             | 只能检测出除null外的基本数据类型和引用数据类型中的function | 不能检测出基本类型，且不能跨iframe | constructor易被修改，也不能跨iframe         | IE6下，undefined和null均为Object |

### 9.8 说说你对闭包的理解？闭包使用场景

>​     闭包是指在函数外部可以访问函数内部变量,是嫁接函数内外部的桥梁,闭包有一个返回值,返回值是函数,过多的使用会导致导致内存泄漏。解决闭包带来的内存泄漏问题的方法是：使用完闭包函数后手动释放。
>
>​     闭包常用于
>
>1. `return` 回一个函数  
>2. 函数作为参数
>3. IIFE（自执行函数）
>4. 循环赋值
>5. 使用回调函数就是在使用闭包
>6. 节流防抖
>7. 函数柯里化

### 9.9 说一说函数的柯里化

>柯里化（Currying），又称部分求值（Partial Evaluation），把接收多参的函数转化成可以逐个调用单个参数并返回接收剩下参数的函数
>
>```
>curriedSum(1, 2, 3)  ---->  curriedSum(1)(2)(3)
>```

### 9.10 说说你对作用域和作用域链的理解

>作用域分为: 全局作用域,函数作用域,块级作用域三种,在es6之前只有全局作用域和函数作用域,es6新增了块级作用域.
>
>作用域链式,当在`Javascript`中使用一个变量的时候，首先`Javascript`引擎会尝试在当前作用域下去寻找该变量，如果没找到，再到它的上层作用域寻找，以此类推直到找到该变量或是已经到了全局作用域.如果在全局作用域里仍然找不到该变量，它就会在全局范围内隐式声明该变量(非严格模式下)或是直接报错

### 9.11 谈谈null和undefined区别

>首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。undefined 代表的含义是**未定义**，null 代表的含义是**空对象**。一般变量声明了但还没有定义的时候会返回 undefined，null主要用于赋值给一些可能会返回对象的变量，作为初始化。Undefined可以作为一个变量名

### 9.12 说一说 for...in和for...of的区别

>for…of 是ES6新增的遍历方式，允许遍历一个含有iterator接口的数据结构（数组、对象等）并且返回各项的值，和ES3中的for…in的区别如下
>
>- for…of 遍历获取的是对象的键值，for…in 获取的是对象的键名；
>- for… in 会遍历对象的整个原型链，性能非常差不推荐使用，而 for … of 只遍历当前对象不会遍历原型链；
>- 对于数组的遍历，for…in 会返回数组中所有可枚举的属性(包括原型链上可枚举的属性)，for…of 只返回数组的下标对应的属性值；
>
>**总结：** for...in 循环主要是为了遍历对象而生，不适用于遍历数组；for...of 循环可以用来遍历数组、类数组对象，字符串、Set、Map 以及 Generator 对象。
>
>

### 9.13 数组的遍历方法有哪些

>| **方法**                  | **是否改变原数组** | **特点**                                                     |
>| ------------------------- | ------------------ | ------------------------------------------------------------ |
>| forEach()                 | 否                 | 数组方法，不改变原数组的长度，没有返回值                     |
>| map()                     | 否                 | 数组方法，不改变原数组的长度，有返回值，可链式调用           |
>| filter()                  | 否                 | 数组方法，过滤数组，返回包含符合条件的元素的数组，可链式调用 |
>| for...of                  | 否                 | for...of遍历具有Iterator迭代器的对象的属性，返回的是数组的元素、对象的属性值，不能遍历普通的obj对象，将异步循环变成同步循环 |
>| every() 和 some()         | 否                 | 数组方法，some()只要有一个是true，便返回true；而every()只要有一个是false，便返回false. |
>| find() 和 findIndex()     | 否                 | 数组方法，find()返回的是第一个符合条件的值；findIndex()返回的是第一个返回条件的值的索引值 |
>| reduce() 和 reduceRight() | 否                 | 数组方法，reduce()对数组正序操作；reduceRight()对数组逆序操作 |

### 9.14 forEach和map方法有什么区别

>这方法都是用来遍历数组的，两者区别如下：
>
>- forEach()方法会针对每一个元素执行提供的函数，如果遍历的元素是引用数据类型，则可以改变指针指向的堆内存里的值，该方法没有返回值；
>- map()方法返回一个新数组，新数组中的值为原数组调用函数处理之后的值，如果遍历的元素是引用数据类型，则可以改变指针指向的堆内存里的值

### 9.15 说说你对递归函数的理解

>如果一个函数在内部调用自身本身，这个函数就是递归函数
>
>其核心思想是把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解
>
>一般来说，递归需要有边界条件、递归前进阶段和递归返回阶段。当边界条件不满足时，递归前进；当边界条件满足时，递归返回
>
>**优点**：结构清晰、可读性强
>
>**缺点**：<span style="color:red">效率低、调用栈可能会溢出</span>，其实每一次函数调用会在内存栈中分配空间，而每个进程的栈的容量是有限的，当调用的层次太多时，就会超出栈的容量，从而导致栈溢出。
>
>--------------
>
>还有一种特殊的递归形式尾递归,尾递归，即在函数尾位置调用自身（或是一个尾调用本身的其他函数等等）。尾递归也是递归的一种特殊情形。尾递归是一种特殊的尾调用，即在尾部直接调用自身的递归函数

### 9.16 说一说内存泄露和解决内存泄露的方法

>内存泄漏（Memory leak）是在计算机科学中，由于疏忽或错误造成程序未能释放已经不再使用的内存,js 具有自动垃圾回收机制（GC：Garbage Collecation），也就是说，执行环境会负责管理代码执行过程中使用的内存
>
>原理：垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存
>
>通常情况下有两种实现方式：
>
>- 标记清除
>- 引用计数

### 9.17 说一说let、const、var的区别

### 9.18  什么是事件冒泡（Event Bubbling）

>事件开始由最具体的元素（⽂档中嵌套层次最深的那个节点）接收到后，开始逐级向上传播到较为不具体的节点。
>
>如果点击了上面页面代码中的 `<button>` 按钮，那么该 `click` 点击事件会沿着 DOM 树向上逐级传播，在途经的每个节点上都会发生，具体顺序如下：
>
>1. button 元素
>2. body 元素
>3. html 元素
>4. document 对象
>
>

### 9.19 什么是事件捕获（Event Capturing）

>事件开始由较为不具体的节点接收后，然后开始逐级向下传播到最具体的元素上。
>
>事件捕获的最大作用在于：事件在到达预定⽬标之前就可以捕获到它。
>
>如果仍以上面那段 HTML 代码为例，当点击按钮后，在事件捕获的过程中，document 对象会首先接收到这个 `click` 事件，然后再沿着 DOM 树依次向下，直到 `<button>`。具体顺序如下：
>
>1. document 对象
>2. html 元素
>3. body 元素
>4. button 元素

### 9.20 什么是事件委托

>事件委托，就是利用了事件冒泡的机制，在较上层位置的元素上添加一个事件监听函数，来管理该元素及其所有子孙元素上的某一类的所有事件。原理是：事件冒泡！
>
>适用场景：在绑定大量事件的时候，可以选择事件委托
>
>**优点**
>
>- 事件委托可以减少事件注册数量，节省内存占⽤!
>- 当新增⼦元素时，⽆需再次做事件绑定，因此非常适合动态添加元素 (vue解析模板时, 会对新创建的元素, 额外进行绑定的)

### 9.21 怎么阻止事件冒泡、阻止默认事件？

>**阻止事件冒泡**
>
>e.stopPropagation()
>
>**阻止默认事件,3种方式**
>
>```csharp
>e.preventDefault();//谷歌及IE8以上
>window.event.returnValue = false; //IE8及以下
>return false; //无兼容问题（但不能用于节点直接onclick绑定函数）
>```
>

### 9.22 说一说ajax和promise和axios原理是什么？如何实现？

>pc端请求原理简单来说通过`XmlHttpRequest`对象来向服务器发异步请求，从服务器获得数据，然后用`JavaScript`来操作`DOM`而更新页面
>
>实现 `Ajax`异步交互需要服务器逻辑进行配合，需要完成以下步骤：
>
>- 创建 `Ajax`的核心对象 `XMLHttpRequest`对象
>- 通过 `XMLHttpRequest` 对象的 `open()` 方法与服务端建立连接
>- 构建请求所需的数据内容，并通过`XMLHttpRequest` 对象的 `send()` 方法发送给服务器端
>- 通过 `XMLHttpRequest` 对象提供的 `onreadystatechange` 事件监听服务器端你的通信状态
>- 接受并处理服务端向客户端响应的数据结果
>- 将处理结果更新到 `HTML`页面中

### 9.23说说Js中的预解析？

>JS 引擎在运行一份代码的时候，会按照下面的步骤进行工作：
>
>1.把变量的声明提升到当前作用域的最前面，只会提升声明，不会提升赋值
>
>2.把函数的声明提升到当前作用域的最前面，只会提升声明，不会提升调用
>
>3.先提升 function，在提升 var

### 9.30变量提升与函数提升的区别？

>**变量提升**
>
>简单说就是在 JavaScript 代码执行前引擎会先进行预编译，预编译期间会将`变量声明与函数声明`提升至其`对应作用域的最顶端`，`函数内声明的变量`只会提升至`该函数作用域最顶层`，`当函数内部定义的一个变量与外部相同时`，那么`函数体内的这个变量就会被上升到最顶端`。
>
>**函数提升**
>
>函数提升只会提升函数声明式写法，函数表达式的写法不存在函数提升
>
>函数提升的优先级大于变量提升的优先级，即函数提升在变量提升之上

### 9.31 什么是箭头函数，有什么特征

>使用 "箭头" ( => ) 来定义函数. 箭头函数相当于匿名函数, 并且简化了函数定义
>
>**箭头函数的特征:**
>
>- 箭头函数没有this, this指向定义箭头函数所处的外部环境
>- 箭头函数的this永远不会变，call、apply、bind也无法改变
>- 箭头函数只能声明成**匿名函数**，但可以通过表达式的方式让箭头函数具名
>- 箭头函数没有原型prototype，即不能用作为构造函数
>- 箭头函数不能当做一个构造函数 因为 this 的指向问题
>- 箭头函数没有 arguments 在箭头函数内部访问这个变量访问的是外部环境的arguments, 可以使用 ...代替

### 9.32  数组常用的方法,字符串常用的方法

## 十、html&css面试题(必须背过的)

### 10.1说说你对盒模型的理解?

>盒模型分为标准盒模型和怪异盒模型
>
>IE盒模型总宽度即就是width宽度=border+padding+内容宽度
>
>标准盒模型总宽度＝border+padding+width
>
>css3 种可以通过设置 box-sizing 属性来完成标准或许怪异盒⼦模型之间的切换,怪异盒⼦模型:box
>
>sizing: border-box;标准盒⼦模型:box-sizing:content-box

### 	10.2 如何实现元素水平垂直居中？

> 居中是一个非常基础但又是非常重要的应用场景，实现居中的方法存在很多，可以将这些方法分成两个大类：
>
>- 居中元素（子元素）的宽高已知
>
>- 居中元素宽高未知
>
>- 实现方式：
>
>  - ### 利用定位+margin:auto
>
>  先上代码：
>
>  ```html
>  <style>
>      .father{
>          width:500px;
>          height:300px;
>          border:1px solid #0a3b98;
>          position: relative;
>      }
>      .son{
>          width:100px;
>          height:40px;
>          background: #f0a238;
>          position: absolute;
>          top:0;
>          left:0;
>          right:0;
>          bottom:0;
>          margin:auto;
>      }
>  </style>
>  <div class="father">
>      <div class="son"></div>
>  </div>
>  ```
>
>  父级设置为相对定位，子级绝对定位 ，并且四个定位属性的值都设置了0，那么这时候如果子级没有设置宽高，则会被拉开到和父级一样宽高
>
>  这里子元素设置了宽高，所以宽高会按照我们的设置来显示，但是实际上子级的虚拟占位已经撑满了整个父级，这时候再给它一个`margin：auto`它就可以上下左右都居中了
>
>  
>
>  ### 利用定位+margin:负值
>
>  绝大多数情况下，设置父元素为相对定位， 子元素移动自身50%实现水平垂直居中
>
>  ```html
>  <style>
>      .father {
>          position: relative;
>          width: 200px;
>          height: 200px;
>          background: skyblue;
>      }
>      .son {
>          position: absolute;
>          top: 50%;
>          left: 50%;
>          margin-left:-50px;
>          margin-top:-50px;
>          width: 100px;
>          height: 100px;
>          background: red;
>      }
>  </style>
>  <div class="father">
>      <div class="son"></div>
>  </div>
>  ```
>
>  整个实现思路如下图所示：
>
>  ![](/Users/nuonuo/Desktop/面试题/面试宝典2.17（终版）/实训阶段/media/922dc300-95f9-11eb-ab90-d9ae814b240d.png)
>
>  - 初始位置为方块1的位置
>  - 当设置left、top为50%的时候，内部子元素为方块2的位置
>  - 设置margin为负数时，使内部子元素到方块3的位置，即中间位置
>
>  这种方案不要求父元素的高度，也就是即使父元素的高度变化了，仍然可以保持在父元素的垂直居中位置，水平方向上是一样的操作
>
>  但是该方案需要知道子元素自身的宽高，但是我们可以通过下面`transform`属性进行移动
>
>  
>
>  ### 利用定位+transform
>
>  实现代码如下：
>
>  ```css
>  <style>
>      .father {
>          position: relative;
>          width: 200px;
>          height: 200px;
>          background: skyblue;
>      }
>      .son {
>          position: absolute;
>          top: 50%;
>          left: 50%;
>    transform: translate(-50%,-50%);
>          width: 100px;
>          height: 100px;
>          background: red;
>      }
>  </style>
>  <div class="father">
>      <div class="son"></div>
>  </div>
>  ```
>
>  `translate(-50%, -50%)`将会将元素位移自己宽度和高度的-50%
>
>  这种方法其实和最上面被否定掉的margin负值用法一样，可以说是`margin`负值的替代方案，并不需要知道自身元素的宽高
>
>  
>
>  
>
>  ### table布局
>
>  设置父元素为`display:table-cell`，子元素设置 `display: inline-block`。利用`vertical`和`text-align`可以让所有的行内块级元素水平垂直居中
>
>  ```html
>  <style>
>      .father {
>          display: table-cell;
>          width: 200px;
>          height: 200px;
>          background: skyblue;
>          vertical-align: middle;
>          text-align: center;
>      }
>      .son {
>          display: inline-block;
>          width: 100px;
>          height: 100px;
>          background: red;
>      }
>  </style>
>  <div class="father">
>      <div class="son"></div>
>  </div>
>  ```
>
>  
>
>  ### flex弹性布局
>
>  还是看看实现的整体代码：
>
>  ```html
>  <style>
>      .father {
>          display: flex;
>          justify-content: center;
>          align-items: center;
>          width: 200px;
>          height: 200px;
>          background: skyblue;
>      }
>      .son {
>          width: 100px;
>          height: 100px;
>          background: red;
>      }
>  </style>
>  <div class="father">
>      <div class="son"></div>
>  </div>
>  ```
>
>  `css3`中了`flex`布局，可以非常简单实现垂直水平居中
>
>  这里可以简单看看`flex`布局的关键属性作用：
>
>  - display: flex时，表示该容器内部的元素将按照flex进行布局
>
>  - align-items: center表示这些元素将相对于本容器水平居中
>  - justify-content: center也是同样的道理垂直居中
>
>  
>
>  ### grid网格布局
>
>  ```html
>  <style>
>      .father {
>              display: grid;
>              align-items:center;
>              justify-content: center;
>              width: 200px;
>              height: 200px;
>              background: skyblue;
>  
>          }
>          .son {
>              width: 10px;
>              height: 10px;
>              border: 1px solid red
>          }
>  </style>
>  <div class="father">
>      <div class="son"></div>
>  </div>
>  ```
>
>  这里看到，`gird`网格布局和`flex`弹性布局都简单粗暴
>
>  
>
>  ### 小结
>
>  上述方法中，不知道元素宽高大小仍能实现水平垂直居中的方法有：
>
>  - 利用定位+margin:auto
>  - 利用定位+transform
>
>  - 利用定位+margin:负值
>
>  - flex布局
>
>  - grid布局
>
>
>
>



### 	10.3  如何实现两栏布局，右侧自适应？三栏布局中间自适应呢？

>- 两栏布局
>
>  - 方法一：实现思路也非常的简单：
>    - 使用 float 左浮左边栏
>    - 右边模块使用 margin-left 撑出内容块做内容展示
>    - 为父级元素添加BFC，防止下方元素飞到上方内容
>
>  代码如下：
>
>  ```html
>  <style>
>      .box{
>          overflow: hidden; 添加BFC
>      }
>      .left {
>          float: left;
>          width: 200px;
>          background-color: gray;
>          height: 400px;
>      }
>      .right {
>          margin-left: 210px;
>          background-color: lightgray;
>          height: 200px;
>      }
>  </style>
>  <div class="box">
>      <div class="left">左边</div>
>      <div class="right">右边</div>
>  </div>
>  ```
>
>  还有一种更为简单的使用则是采取：flex弹性布局
>
>  - 方法二：flex弹性布局
>
>  ```html
>  <style>
>      .box{
>          display: flex;
>      }
>      .left {
>          width: 100px;
>      }
>      .right {
>          flex: 1;
>      }
>  </style>
>  <div class="box">
>      <div class="left">左边</div>
>      <div class="right">右边</div>
>  </div>
>  ```
>
>  `flex`可以说是最好的方案了，代码少，使用简单
>
>  注意的是，`flex`容器的一个默认属性值:`align-items: stretch;`
>
>  这个属性导致了列等高的效果。 为了让两个盒子高度自动，需要设置: `align-items: flex-start`
>
>- 三栏布局
>
>  - 实现三栏布局中间自适应的布局方式有：
>
>    - 两边使用 float，中间使用 margin
>
>    ```js
>    需要将中间的内容放在html结构最后，否则右侧会臣在中间内容的下方
>          
>    实现代码如下：
>          
>    ​html
>    <style>
>        .wrap {
>            background: #eee;
>            overflow: hidden; <!-- 生成BFC，计算高度时考虑浮动的元素 -->
>            padding: 20px;
>            height: 200px;
>        }
>        .left {
>            width: 200px;
>            height: 200px;
>            float: left;
>            background: coral;
>        }
>        .right {
>            width: 120px;
>            height: 200px;
>            float: right;
>            background: lightblue;
>        }
>        .middle {
>            margin-left: 220px;
>            height: 200px;
>            background: lightpink;
>            margin-right: 140px;
>        }
>    </style>
>    <div class="wrap">
>        <div class="left">左侧</div>
>        <div class="right">右侧</div>
>        <div class="middle">中间</div>
>    </div>
>    
>    
>    原理如下：
>    
>    - 两边固定宽度，中间宽度自适应。
>    - 利用中间元素的margin值控制两边的间距
>    - 宽度小于左右部分宽度之和时，右侧部分会被挤下去
>    
>    这种实现方式存在缺陷：
>    
>    - 主体内容是最后加载的。
>    
>    - 右边在主体内容之前，如果是响应式设计，不能简单的换行展示
>    ```
>
>    
>
>    - 两边使用 absolute，中间使用 margin
>
>    ```css
>    基于绝对定位的三栏布局：注意绝对定位的元素脱离文档流，相对于最近的已经定位的祖先元素进行定位。无需考虑HTML中结构的顺序
>    
>    <style>
>      .container {
>        position: relative;
>      }
>      
>      .left,
>      .right,
>      .main {
>        height: 200px;
>        line-height: 200px;
>        text-align: center;
>      }
>    
>      .left {
>        position: absolute;
>        top: 0;
>        left: 0;
>        width: 100px;
>        background: green;
>      }
>    
>      .right {
>        position: absolute;
>        top: 0;
>        right: 0;
>        width: 100px;
>        background: green;
>      }
>    
>      .main {
>        margin: 0 110px;
>        background: black;
>        color: white;
>      }
>    </style>
>    
>    <div class="container">
>      <div class="left">左边固定宽度</div>
>      <div class="right">右边固定宽度</div>
>      <div class="main">中间自适应</div>
>    </div>
>    
>    
>    实现流程：
>    
>    - 左右两边使用绝对定位，固定在两侧。
>    - 中间占满一行，但通过 margin和左右两边留出10px的间隔
>    ```
>
>    
>
>    - 两边使用 float 和负 margin
>
>    ```js
>    <style>
>      .left,
>      .right,
>      .main {
>        height: 200px;
>        line-height: 200px;
>        text-align: center;
>      }
>    
>      .main-wrapper {
>        float: left;
>        width: 100%;
>      }
>    
>      .main {
>        margin: 0 110px;
>        background: black;
>        color: white;
>      }
>    
>      .left,
>      .right {
>        float: left;
>        width: 100px;
>        margin-left: -100%;
>        background: green;
>      }
>    
>      .right {
>        margin-left: -100px; /* 同自身宽度 */
>      }
>    </style>
>    
>    <div class="main-wrapper">
>      <div class="main">中间自适应</div>
>    </div>
>    <div class="left">左边固定宽度</div>
>    <div class="right">右边固定宽度</div>
>    
>    实现过程：
>    
>    - 中间使用了双层标签，外层是浮动的，以便左中右能在同一行展示
>    - 左边通过使用负 margin-left:-100%，相当于中间的宽度，所以向上偏移到左侧
>    - 右边通过使用负 margin-left:-100px，相当于自身宽度，所以向上偏移到最右侧
>    
>     
>    
>    缺点：
>    
>    - 增加了 .main-wrapper 一层，结构变复杂
>    - 使用负 margin，调试也相对麻烦
>    ```
>
>    
>
>    - display: table 实现
>      - `<table>` 标签用于展示行列数据，不适合用于布局。但是可以使用 `display: table` 来实现布局的效果
>
>    ```js
>    <style>
>      .container {
>        height: 200px;
>        line-height: 200px;
>        text-align: center;
>        display: table;
>        table-layout: fixed;
>        width: 100%;
>      }
>    
>      .left,
>      .right,
>      .main {
>        display: table-cell;
>      }
>    
>      .left,
>      .right {
>        width: 100px;
>        background: green;
>      }
>    
>      .main {
>        background: black;
>        color: white;
>        width: 100%;
>      }
>    </style>
>    
>    <div class="container">
>      <div class="left">左边固定宽度</div>
>      <div class="main">中间自适应</div>
>      <div class="right">右边固定宽度</div>
>    </div>
>    
>    实现原理：
>    
>    - 层通过 display: table设置为表格，设置 table-layout: fixed`表示列宽自身宽度决定，而不是自动计算。
>    - 内层的左中右通过 display: table-cell设置为表格单元。
>    - 左右设置固定宽度，中间设置 width: 100% 填充剩下的宽度
>    ```
>
>    
>
>    - flex实现
>
>      - 利用`flex`弹性布局，可以简单实现中间自适应
>      - 代码如下：
>
>      ```js
>      <style type="text/css">
>          .wrap {
>              display: flex;
>              justify-content: space-between;
>          }
>                
>          .left,
>          .right,
>          .middle {
>              height: 100px;
>          }
>                
>          .left {
>              width: 200px;
>              background: coral;
>          }
>                
>          .right {
>              width: 120px;
>              background: lightblue;
>          }
>                
>          .middle {
>              background: #555;
>              width: 100%;
>              margin: 0 20px;
>          }
>      </style>
>      <div class="wrap">
>          <div class="left">左侧</div>
>          <div class="middle">中间</div>
>          <div class="right">右侧</div>
>      </div>
>                
>      实现过程：
>                
>      - 仅需将容器设置为`display:flex;`，
>      - 盒内元素两端对其，将中间元素设置为`100%`宽度，或者设为`flex:1`，即可填充空白
>      - 盒内元素的高度撑开容器的高度
>                
>      优点：
>                
>      - 结构简单直观
>      - 可以结合 flex的其他功能实现更多效果，例如使用 order属性调整显示顺序，让主体内容优先加载，但展示在中间
>      ```
>
>      
>
>    - grid网格布局
>
>      代码如下:
>
>    ```css
>    <style>
>        .wrap {
>            display: grid;
>            width: 100%;
>            grid-template-columns: 300px auto 300px;
>        }
>    
>        .left,
>        .right,
>        .middle {
>            height: 100px;
>        }
>    
>        .left {
>            background: coral;
>        }
>    
>        .right {
>            width: 300px;
>            background: lightblue;
>        }
>    
>        .middle {
>            background: #555;
>        }
>    </style>
>    <div class="wrap">
>        <div class="left">左侧</div>
>        <div class="middle">中间</div>
>        <div class="right">右侧</div>
>    </div>
>    ```
>
>



### 10.4 1.6 CSS如何画一个三角形？原理是什么？

>通常情况下我们会使用图片或者`svg`去完成三角形效果图，但如果单纯使用`css`如何完成一个三角形呢？
>
>实现过程似乎也并不困难，通过边框就可完成
>
>- 实现过程
>
>在以前也讲过盒子模型，默认情况下是一个矩形，实现也很简单
>
>```html
><style>
>    .border {
>        width: 50px;
>        height: 50px;
>        border: 2px solid;
>        border-color: #96ceb4 #ffeead #d9534f #ffad60;
>    }
></style>
><div class="border"></div>
>```
>
>效果如下图所示：
>
> ![](/Users/nuonuo/Desktop/面试题/面试宝典2.17（终版）/实训阶段/media/e3f244e0-a279-11eb-ab90-d9ae814b240d.png)
>
>
>
>将`border`设置`50px`，效果图如下所示：
>
>![](/Users/nuonuo/Desktop/面试题/面试宝典2.17（终版）/实训阶段/media/ee0b42b0-a279-11eb-ab90-d9ae814b240d.png)

>白色区域则为`width`、`height`，这时候只需要你将白色区域部分宽高逐渐变小，最终变为0，则变成如下图所示：
>
> ![](/Users/nuonuo/Desktop/面试题/面试宝典2.17（终版）/实训阶段/media/2afaa030-a27a-11eb-85f6-6fac77c0c9b3.png)





>这时候就已经能够看到4个不同颜色的三角形，如果需要下方三角形，只需要将上、左、右边框设置为0就可以得到下方的红色三角形 
>
>![](/Users/nuonuo/Desktop/面试题/面试宝典2.17（终版）/实训阶段/media/2afaa030-a27a-11eb-85f6-6fac77c0c9b3.png)
>
>但这种方式，虽然视觉上是实现了三角形，但实际上，隐藏的部分任然占据部分高度，需要将上方的宽度去掉
>
>最终实现代码如下：
>
>```css
>.border {
>    width: 0;
>    height: 0;
>    border-style:solid;
>    border-width: 0 50px 50px;
>    border-color: transparent transparent #d9534f;
>}
>```
>
>如果想要实现一个只有边框是空心的三角形，由于这里不能再使用`border`属性，所以最直接的方法是利用伪类新建一个小一点的三角形定位上去
>
>```css
>.border {
>    width: 0;
>    height: 0;
>    border-style:solid;
>    border-width: 0 50px 50px;
>    border-color: transparent transparent #d9534f;
>    position: relative;
>}
>.border:after{
>    content: '';
>    border-style:solid;
>    border-width: 0 40px 40px;
>    border-color: transparent transparent #96ceb4;
>    position: absolute;
>    top: 0;
>    left: 0;
>}
>```
>
>效果图如下所示：
>
> ![i](/Users/nuonuo/Desktop/面试题/面试宝典2.17（终版）/实训阶段/media/59f4d720-a27a-11eb-85f6-6fac77c0c9b3.png)
>
>
>
>
>
>
>
>伪类元素定位参照对象的内容区域宽高都为0，则内容区域即可以理解成中心一点，所以伪元素相对中心这点定位
>
>将元素定位进行微调以及改变颜色，就能够完成下方效果图：
>
> ![](/Users/nuonuo/Desktop/面试题/面试宝典2.17（终版）/实训阶段/media/653a6e10-a27a-11eb-85f6-6fac77c0c9b3.png)
>
>
>
>最终代码如下：
>
>```css
>.border:after {
>    content: '';
>    border-style: solid;
>    border-width: 0 40px 40px;
>    border-color: transparent transparent #96ceb4;
>    position: absolute;
>    top: 6px;
>    left: -40px;
>}
>```
>
>- 原理分析
>
>可以看到，边框是实现三角形的部分，边框实际上并不是一个直线，如果我们将四条边设置不同的颜色，将边框逐渐放大，可以得到每条边框都是一个梯形
>
>![](/Users/nuonuo/Desktop/面试题/面试宝典2.17（终版）/实训阶段/media/78d4bd90-a27a-11eb-85f6-6fac77c0c9b3.png)
>
>当分别取消边框的时候，发现下面几种情况：
>
>- 取消一条边的时候，与这条边相邻的两条边的接触部分会变成直的
>- 当仅有邻边时， 两个边会变成对分的三角
>- 当保留边没有其他接触时，极限情况所有东西都会消失
>
>![](/Users/nuonuo/Desktop/面试题/面试宝典2.17（终版）/实训阶段/media/84586ef0-a27a-11eb-85f6-6fac77c0c9b3.png)
>
>通过上图的变化规则，利用旋转、隐藏，以及设置内容宽高等属性，就能够实现其他类型的三角形
>
>如设置直角三角形，如上图倒数第三行实现过程，我们就能知道整个实现原理
>
>实现代码如下：
>
>```css
>.box {
>    /* 内部大小 */
>    width: 0px;
>    height: 0px;
>    /* 边框大小 只设置两条边*/
>    border-top: #4285f4 solid;
>    border-right: transparent solid;
>    border-width: 85px; 
>    /* 其他设置 */
>    margin: 50px;
>}
>```
>



### 	10.5 说说em/px/rem/vh/vw区别?

>**px**：绝对单位，页面按精确像素展示
>
>**em**：相对单位，基准点为父节点字体的大小，如果自身定义了`font-size`按自身来计算，整个页面内`1em`不是一个固定的值
>
>**rem**：相对单位，可理解为`root em`, 相对根节点`html`的字体大小来计算
>
>**vh、vw**：主要用于页面视口大小布局，在页面布局上更加方便简单
>
>

### 10.6  BFC的理解？

>```
>BFC（Block Formatting Context），即块级格式化上下文，它是页面中的一块渲染区域，并且有一套属于自己的渲染规则：
>
>- 内部的盒子会在垂直方向上一个接一个的放置
>- 对于同一个BFC的俩个相邻的盒子的margin会发生重叠，与方向无关。
>- 每个元素的左外边距与包含块的左边界相接触（从左到右），即使浮动元素也是如此
>- BFC的区域不会与float的元素区域重叠
>- 计算BFC的高度时，浮动子元素也参与计算
>- BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然
>
>BFC目的是形成一个相对于外界完全独立的空间，让内部的子元素不会影响到外部的元素
>
>  2.触发BFC的条件包含不限于：
>
>- 根元素，即HTML元素
>- 浮动元素：float值为left、right
>- overflow值不为 visible，为 auto、scroll、hidden
>- display的值为inline-block、inltable-cell、table-caption、table、inline-table、flex、inline-flex、grid、inline-grid
>- position的值为absolute或fixed
>  3.利用BFC的特性，我们将`BFC`应用在以下场景：
>  	防止margin重叠（塌陷）
>  	清除内部浮动
>  	自适应多栏布局
>```



### 10.7 H5新增特性和css3新增特性？

>1.首先 html5 为了更好的实践 web 语义化，增加了 header，footer，nav,aside,section 等语义 化标签，
>	  2.在表单方面，为了增强表单，为 input 增加了 color，email,data ,range 等类型， 
>	  3.在存储方面，提供了 sessionStorage，localStorage,和离线存储，通过这些存储方式方便数 据在客户端的存储和获取，
>	  4.在多媒体方面规定了音频和视频元素 audio 和 vedio，另外还 有地理定位，canvas 画布，拖放，多线程编程的 web worker 和 websocket协议
>	  5.css3新增特性：
>	  		CSS3 边框如 border-radius，box-shadow 等;
>	  		CSS3 背景如 background-size，background-origin 等;
>	  		CSS3 2D，3D 转换如 transform 等;
>	  		CSS3 动画如 animation 等
>	  

### 10.8 优雅降级和渐进增强

### 10.9 怎么理解回流跟重绘？什么场景下会触发？如何减少回流和重绘呢?

>在`HTML`中，每个元素都可以理解成一个盒子，在浏览器解析过程中，会涉及到回流与重绘：
>
>- 回流：布局引擎会根据各种样式计算每个盒子在页面上的大小与位置
>- 重绘：当计算好盒模型的位置、大小及其他属性后，浏览器根据每个盒子特性进行绘制
>
>### 回流触发时机
>
>回流这一阶段主要是计算节点的位置和几何信息，那么当页面布局和几何信息发生变化的时候，就需要回流，如下面情况：
>
>- 添加或删除可见的DOM元素
>- 元素的位置发生变化
>- 元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）
>- 内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代
>- 页面一开始渲染的时候（这避免不了）
>- 浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）
>
>还有一些容易被忽略的操作：获取一些特定属性的值
>
>> offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight
>
>这些属性有一个共性，就是需要通过即时计算得到。因此浏览器为了获取这些值，也会进行回流
>
>除此还包括`getComputedStyle`方法，原理是一样的
>
>###  重绘触发时机重绘触发时
>
>触发回流一定会触发重绘
>
>可以把页面理解为一个黑板，黑板上有一朵画好的小花。现在我们要把这朵从左边移到了右边，那我们要先确定好右边的具体位置，画好形状（回流），再画上它原有的颜色（重绘）
>
>除此之外还有一些其他引起重绘行为：
>
>- 颜色的修改
>- 文本方向的修改
>- 阴影的修改
>
>###  浏览器优化机制
>
>由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列
>
>当你获取布局信息的操作的时候，会强制队列刷新，包括前面讲到的`offsetTop`等方法都会返回最新的数据
>
>因此浏览器不得不清空队列，触发回流重绘来返回正确的
>
>### 减少回流和重绘方法
>
>- 如果想设定元素的样式，通过改变元素的 `class` 类名 (尽可能在 DOM 树的最里层)
>- 避免设置多项内联样式
>- 应用元素的动画，使用 `position` 属性的 `fixed` 值或 `absolute` 值(如前文示例所提)
>- 避免使用 `table` 布局，`table` 中每个元素的大小以及内容的改动，都会导致整个 `table` 的重新计算
>- 对于那些复杂的动画，对其设置 `position: fixed/absolute`，尽可能地使元素脱离文档流，从而减少对其他元素的影响
>- 使用css3硬件加速，可以让`transform`、`opacity`、`filters`这些动画不会引起回流重绘
>- 避免使用 CSS 的 `JavaScript` 表达式



### 10.10 说一说浏览器的渲染机制

>步骤如下
>
>- 解析HTML，生成DOM树，解析CSS，生成CSSOM树
>- 将DOM树和CSSOM树结合，生成渲染树(Render Tree)
>- Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小）
>- Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素
>- Display:将像素发送给GPU，展示在页面上
>
>在页面初始渲染阶段，回流不可避免的触发，可以理解成页面一开始是空白的元素，后面添加了新的元素使页面布局发生改变
>
>当我们对 `DOM` 的修改引发了 `DOM`几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性，然后再将计算的结果绘制出来
>
>当我们对 `DOM`的修改导致了样式的变化（`color`或`background-color`），却并未影响其几何属性时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式，这里就仅仅触发了重绘

### 10.11 什么是响应式设计？响应式设计的基本原理是什么？如何做？

>响应式网站设计（Responsive Web design）是一种网络页面设计布局，页面的设计与开发应当根据用户行为以及设备环境(系统平台、屏幕尺寸、屏幕定向等)进行相应的响应和调整
>
>## 二、实现方式
>
>响应式设计的基本原理是通过媒体查询检测不同的设备屏幕尺寸做处理，为了处理移动端，页面头部必须有`meta`声明`viewport`
>
>```html
><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no”>
>```
>
>属性对应如下：
>
>- width=device-width: 是自适应手机屏幕的尺寸宽度
>- maximum-scale:是缩放比例的最大值
>- inital-scale:是缩放的初始化
>- user-scalable:是用户的可以缩放的操作
>
>实现响应式布局的方式有如下：
>
>- 媒体查询
>- 百分比
>- vw/vh
>- rem

### 10.12css选择器有哪些？优先级？哪些属性可以继承？

>关于`css`属性选择器常用的有：
>
>- id选择器（#box），选择id为box的元素
>- 类选择器（.one），选择类名为one的所有元素
>- 标签选择器（div），选择标签为div的所有元素
>- 后代选择器（#box div），选择id为box元素内部所有的div元素
>- 子选择器（.one>one_1），选择父元素为.one的所有.one_1的元素
>- 相邻同胞选择器（.one+.two），选择紧接在.one之后的所有.two元素
>- 群组选择器（div,p），选择div、p的所有元素
>
>还有一些使用频率相对没那么多的选择器：
>
>- 伪类选择器
>- 伪元素选择器
>- 属性选择器
>
>## 优先级
>
>> 内联 > ID选择器 > 类选择器 > 标签选择器
>
>## 继承属性
>
>在`css`中，继承是指的是给父元素设置一些属性，后代元素会自动拥有这些属性
>
>关于继承属性，可以分成：
>
>- 字体系列属性
>- 文本系列属性
>- 元素可见性
>- 表格布局属性
>- 列表属性
>- 引用
>- 光标属性
>- 继承中比较特殊的几点：
>  - a 标签的字体颜色不能被继承
>  - h1-h6标签字体的大下也是不能被继承的
>
>### 无继承属性的有
>
>- display
>- 文本属性：vertical-align、text-decoration
>- 盒子模型的属性：宽度、高度、内外边距、边框等
>- 背景属性：背景图片、颜色、位置等
>- 定位属性：浮动、清除浮动、定位position等
>- 生成内容属性：content、counter-reset、counter-increment
>- 轮廓样式属性：outline-style、outline-width、outline-color、outline
>- 页面样式属性：size、page-break-before、page-break-after

### 10.13css3动画有哪些？

>CSS动画（CSS Animations）是为层叠样式表建议的允许可扩展标记语言（XML）元素使用CSS的动画的模块
>
>即指元素从一种样式逐渐过渡为另一种样式的过程
>
>常见的动画效果有很多，如平移、旋转、缩放等等，复杂动画则是多个简单动画的组合
>
>`css`实现动画的方式，有如下几种：
>
>- transition 实现渐变动画
>- transform 转变动画
>- animation 实现自定义动画

### 10.14  说说对Css预编译器有哪些?Css预编译器的理解？有哪些区别?为什么要诞生css预编译器

>​      Css预编译有less,sass/scss,Stylus等,css预编译器出现的原因是因为css是一门标记类的语言,编写出来的css看似没有逻辑,而且不便于后期的维护和更新迭代,所以预编译器应用而生.预编译器扩充了 `Css` 语言，增加了诸如变量、混合（mixin）、函数等功能，让 `Css` 更易维护、方便.本质上，预处理是`Css`的超集
>
>​	    相同点:
>
>​               less,sass,stylus都具有变量,作用域,代码混合,嵌套,代码模块化这些功能.
>
>​        不同点:
>
>​              Less是基于JavaScript，是在客户端处理的。 Sass是基于Ruby的，是在[服务器](https://cloud.tencent.com/product/cvm?from_column=20065&from=20065)端处理的
>
>​               两者声明变量方式不一样.less使用@,sass使用$,less只是使用css内置的函数,sass可以想js一样,编写函数
>
>最后基于以上区别,选择了sass作为预处理器,能够变相的节约一些性能,
>
> 

## 十一、移动端面试题

### 11.1移动端你们一般采用什么布局？移动端设计稿是多大的尺寸？

>一般移动端设计稿是640或者750的尺寸
>
>

### 11.2 ios、安卓兼容性

1. ios 设置input 按钮样式会被默认样式覆盖

   ```css
   input,textarea {
     border: 0;
     -webkit-appearance: none;
   }
   
   ```

2. 禁止ios和android用户选中文字

   ```sql
   -webkit-user-select:none
   
   ```

3. ios下取消input在输入的时候英文首字母的默认大写

   ```ini
   <input autocapitalize="off" autocorrect="off" />
   
   ```

4. 禁止 ios 弹出各种操作窗口

   ```css
   -webkit-touch-callout:none
   
   ```

5. ios会识别长串数字为电话,导致变色

   ```ini
   <meta content="telephone=no" name="format-detection" />
   
   ```

6. ios系统中文输入法输入英文时，字母之间可能会出现一个六分之一空格

   ```kotlin
   可以通过正则去掉 `this.value = this.value.replace(/\u2006/g, '');`
   
   ```

7. input输入框聚焦

   input输入框在聚焦的时候，ios有时候会出现outline或者阴影，安卓则是显示正常的

   解决方案：

   ```css
   input:focus{outline:none} input:{-webkit-appearance: none;}
   
   ```

8. fixed定位缺陷

   ios下fixed元素容易定位出错，软键盘弹出时，影响fixed元素定位

   android下fixed表现要比iOS更好，软键盘弹出时，不会影响fixed元素定位

   ios4下不支持position:fixed

   解决方案:用iScroll插件

9. input输入框type类型为number的时候会出现上下的箭头

   解决方案: 隐藏箭头

   ```css
   input::-webkit-outer-spin-button, 
   input::-webkit-inner-spin-button { -webkit-appearance: none !important; margin: 0; }
   ```

### 11.3 日期格式问题

new Date('2020-01-01') 转 NaN-NaN-NaN 需要 new Date('2020-01-01'.replace(/-/g, '/'))

### 11.4  ios调起数字键盘(可能会出现的情况)

```ini
<input
    type="number"
    v-model="amount"
    pattern="[0-9]*"
    placeholder="输入金额"
  />

```

当input的type为number时，安卓可被调起数字键盘，但不兼容ios

```ini
pattern="[0-9]*"  此参数可以兼容ios与安卓
```

链接文档 

https://zhuanlan.zhihu.com/p/83969781

https://www.cnblogs.com/wfblog/p/11403460.html

https://blog.csdn.net/mChales_Liu/article/details/122193185

## 十二、性能优化&工程化面试题(webpack/vite)(必须背过的)

###  12.1 说说你对webpack的理解？解决了什么问题？

>​        `Webpack` 最初的目标是实现前端项目的模块化，旨在更高效地管理和维护项目中的每一个资源,`webpack` 是一个用于现代`JavaScript`应用程序的静态模块打包工具,其底层是根据node.js封装的一个服务器

### 12.2 说说webpack中常见的Loader？解决了什么问题？

>​      `loader` 用于对模块的"源代码"进行转换，在 `import` 或"加载"模块时预处理文件,像`css`、`sass`、`png`等这些类型的文件的时候，`webpack`则无能为力，这时候就需要配置对应的`loader`进行文件内容的解析,处理成浏览器可以识别的语言
>
>​      常用的loader有
>
>- style-loader: 将css添加到DOM的内联样式标签style里
>- css-loader :允许将css文件通过require的方式引入，并返回css代码
>- less-loader: 处理less
>- sass-loader: 处理sass
>- postcss-loader: 用postcss来处理CSS
>- autoprefixer-loader: 处理CSS3属性前缀，已被弃用，建议直接使用postcss
>- file-loader: 分发文件到output目录并返回相对路径
>- url-loader: 和file-loader类似，但是当文件小于设定的limit时可以返回一个Data Url
>- html-minify-loader: 压缩HTML
>- babel-loader :用babel来转换ES6文件到ES
>
>```js
>rules: [
>  ...,
> {
>  test: /\.css$/,
>    use: {
>      loader: "css-loader",
>      options: {
>     // 启用/禁用 url() 处理
>     url: true,
>     // 启用/禁用 @import 处理
>     import: true,
>        // 启用/禁用 Sourcemap
>        sourceMap: false
>      }
>    }
> }
>]
>```

### 12.3 说说webpack中常见的Plugin？解决了什么问题？

>plugin 赋予了 webpack 各种灵活的功能，例如打包优化、资源管理、环境变量注入等，目的是解决 loader 无法实现的其他事
>
>常用的plugin有
>
>* ###  HtmlWebpackPlugin  在打包结束后，⾃动生成⼀个 `html` ⽂文件，并把打包生成的`js` 模块引⼊到该 `html` 中
>
>* ### clean-webpack-plugin  删除（清理）构建目录
>
>* ### mini-css-extract-plugin 提取 `CSS` 到一个单独的文件中 做到压缩和优化
>
>* ### DefinePlugin  允许在编译时创建配置的全局对象，是一个`webpack`内置的插件，不需要安装
>
>* 还有一个插件,清空线上的console输出
>
>```
>module.exports = {
>  ...
>  plugins: [
>    new webpack.ProgressPlugin(),
>    new HtmlWebpackPlugin({ template: './src/index.html' }),
>  ],
>};
>```
>
>

### 12.4 说说如何借助webpack来优化前端性能？

>通过`webpack`优化前端的手段有：
>
>- JS代码压缩
>- CSS代码压缩
>- Html文件代码压缩
>- 文件大小压缩
>- 图片压缩
>- Tree Shaking
>- 代码分离
>- 内联 chunk
>
>关于`webpack`对前端性能的优化，可以通过文件体积大小入手，其次还可通过分包的形式、减少http请求次数等方式，实现对前端性能的优化

### 12.5 如何提高webpack的构建速度？

>​       优化 loader 配置,提高对cpu的利用,实现多进程开发, 合理利用缓存,减少构建时间,优化压缩时间,使用terser 启动多进程打包,速度更快

### 12.6  如何提高webpack的启动速度？

>​        如果使用 chrome 浏览器，那么在开发环境下，其实可以关闭 babel 的转义, 还有可以添加 babel 的缓存, 简化查找路径的，配置路径的代理标识
>
>

### 12.7 webpack的五大核心是什么?

>
>
>- entry   入口文件
>
>- output  出口文件
>
>- module=>rules:[{loader配置}]
>
>- plugins  插件
>
>- devServer  代理
>
>  
>
>

### 12.8  与webpack类似的工具还有哪些？区别？

>类似的打包工具有Rollup, Parcel,vite,Snowpack等
>
>其他工具基本都只有自己的特长,只有webpack大而全,包括了所有的配置,能够完成所有的配置项,并且是开源项目,兼容性特别好,
>
>vite是下一代的开发工具

### 12.9 开发阶段vite的速度远快于webpack?

>总的来说,**webpack是先打包再启动开发服务器，vite是直接启动开发服务器，然后按需编译依赖文件。**
>
>详细说就是,
>
>webpack先打包，再启动开发服务器，请求服务器时直接给予打包后的结果；
>
>vite直接启动开发服务器，请求哪个模块再对哪个模块进行实时编译；
>
>由于现代浏览器本身就支持ES Modules，会主动发起请求去获取所需文件。vite充分利用这点，将开发环境下的模块文件，就作为浏览器要执行的文件，而不是像webpack先打包，交给浏览器执行的文件是打包后的；
>
>由于vite启动的时候不需要打包，也就无需分析模块依赖、编译，所以启动速度非常快。当浏览器请求需要的模块时，再对模块进行编译，这种按需动态编译的模式，极大缩短了编译时间，当项目越大，文件越多时，vite的开发时优势越明显；
>
>在HRM方面，当某个模块内容改变时，让浏览器去重新请求该模块即可，而不是像webpack重新将该模块的所有依赖重新编译；
>
>当需要打包到生产环境时，vite使用传统的rollup进行打包，所以，vite的优势是体现在开发阶段，另外，由于vite使用的是ES Module，所以代码中不可以使用CommonJs；

### 12.10  vite 对比 webpack ，优缺点在哪 ? 或者 为什么vite是下一代构建工具

>`优点`：
>
>1. **更快的冷启动**：`Vite` 借助了浏览器对 `ESM` 规范的支持，采取了与 `Webpack` 完全不同的 `unbundle` 机制
>2. **更快的热更新**：`Vite` 采用 `unbundle` 机制，所以 `dev server` 在监听到文件发生变化以后，只需要通过 `ws` 连接通知浏览器去重新加载变化的文件，剩下的工作就交给浏览器去做了。
>
>`缺点`：
>
>1. **开发环境下首屏加载变慢**：由于 `unbundle` 机制，`Vite` 首屏期间需要额外做其它工作。不过首屏性能差只发生在 `dev server` 启动以后第一次加载页面时发生。之后再 `reload` 页面时，首屏性能会好很多。原因是 `dev server` 会将之前已经完成转换的内容缓存起来
>2. **开发环境下懒加载变慢**：跟首屏加载变慢的原因一样。`Vite` 在懒加载方面的性能也比 `Webpack` 差。由于 `unbundle` 机制，动态加载的文件，需要做 `resolve`、`load`、`transform`、`parse` 操作，并且还有大量的 `http` 请求，导致懒加载性能也受到影响。
>3. **webpack支持的更广**。由于 `Vite` 基于ES Module，所以代码中不可以使用CommonJs；webpack更多的关注兼容性, 而`Vite` 关注浏览器端的开发体验。`Vite`目前生态还不如 `Webpack`。

## 十三、Git面试题

### 13.1  说一下你知道的版本控制有哪些?

>常用的版本控制有:
>
>- 本地版本控制系统
>- 集中式版本控制系统  svn
>- 分布式版本控制系统   git  github  gitlab
>
>版本控制系统的优点如下：
>
>- 记录文件所有历史变化，这是版本控制系统的基本能力
>- 随时恢复到任意时间点，历史记录功能使我们不怕改错代码了
>- 支持多功能并行开发，通常版本控制系统都支持分支，保证了并行开发的可行
>- 多人协作并行开发，对于多人协作项目，支持多人协作开发的版本管理将事半功倍

### 13.2 说一说你常用的git命令有哪些

>- git init 初始化仓库，默认为 master 分支
>- git add . 提交全部文件修改到缓存区
>- git add <具体某个文件路径+全名> 提交某些文件到缓存区
>- git diff 查看当前代码 add后，会 add 哪些内容
>- git diff --staged查看现在 commit 提交后，会提交哪些内容
>- git status 查看当前分支状态
>- git pull <远程仓库名> <远程分支名> 拉取远程仓库的分支与本地当前分支合并
>- git pull <远程仓库名> <远程分支名>:<本地分支名> 拉取远程仓库的分支与本地某个分支合并
>- git commit -m "<注释>" 提交代码到本地仓库，并写提交注释
>- git branch 查看本地所有分支
>- git merge <分支名> 合并分支
>- git checkout <分支名> 切换到本地某个分支
>- git fetch [remote] 下载远程仓库的所有变动
>- git push [remote] [branch] 上传本地指定分支到远程仓库
>- git reset --hard 重置暂存区与工作区，与上一次commit保持一致
>
>关于提交信息的格式，可以遵循以下的规则：
>
>- feat: 新特性，添加功能
>- fix: 修改 bug
>- refactor: 代码重构
>- docs: 文档修改
>- style: 代码格式修改, 注意不是 css 修改
>- test: 测试用例修改
>- chore: 其他修改, 比如构建流程, 依赖管理



### 14.7 git中出现冲突怎么解决?以及出现冲突的原因

>​         出现冲突的原因是因为我们两个人同时修改了一行代码,他上传了,我pull下来后出现冲突,如果我修改的需求是最新的需求,那么就以我为准,如果是之前的就和同事一起商量一下



### 14.8 我想把一个分支上的一些commit提交到另一个分支,怎么做?

>使用git cherry-pick这个命令,其中A是要合并的commitid 开发,b是commitid的结束,查看commitid使用  git ref
>
>```
>git cherry-pick A...B 
>```



### 14.9 说说对git pull 和 git fetch 的理解？有什么区别？

>- git fetch 命令用于从另一个存储库下载对象和引用
>- git pull 命令用于从另一个存储库或本地分支获取并集成(整合)
>
>相同点：
>
>- 在作用上他们的功能是大致相同的，都是起到了更新代码的作用
>
>不同点：
>
>- git pull是相当于从远程仓库获取最新版本，然后再与本地分支merge，即git pull = git fetch + git merge
>- 相比起来，git fetch 更安全也更符合实际要求，在 merge 前，我们可以查看更新情况，根据实际情况再决定是否合并
>
>

## 十四、HTTP面试题(必须背过的)

### 14.1 什么是HTTP? HTTP 和 HTTPS 的区别?

>​          `HTTP` (HyperText Transfer Protocol)，即超文本运输协议，是实现网络通信的一种规范,http和https的区别是
>
>​            HTTPS为了保证这些隐私数据能加密传输，让`HTTP`运行安全的`SSL/TLS`协议上，即 HTTPS = HTTP + SSL/TLS，通过 `SSL`证书来验证服务器的身份，并为浏览器和服务器之间的通信进行加密`SSL` 协议位于`TCP/IP` 协议与各种应用层协议之间，浏览器和服务器在使用 `SSL` 建立连接时需要选择一组恰当的加密算法来实现安全通信，为数据通讯提供安全支持
>
>两者的区别是
>
>-  HTTPS是HTTP协议的安全版本，HTTP协议的数据传输是明文的，是不安全的，HTTPS使用了SSL/TLS协议进行了加密处理，相对更安全
>- HTTP 和 HTTPS 使用连接方式不同，默认端口也不一样，HTTP是80，HTTPS是443
>- HTTPS 由于需要设计加密以及多次握手，性能方面不如 HTTP
>- HTTPS需要SSL，SSL 证书需要钱，功能越强大的证书费用越高

### 14.2 说说地址栏输入 URL 敲下回车后发生了什么?

>简单的分析，从输入 `URL`到回车后发生的行为如下：
>
>- URL解析
>- DNS 查询
>- TCP 连接
>- HTTP 请求
>- 响应请求
>- 页面渲染

### 14.3 页面渲染的过程

>- 解析HTML，构建 DOM 树
>- 解析 CSS ，生成 CSS 规则树
>- 合并 DOM 树和 CSS 规则，生成 render 树
>- 布局 render 树（ Layout / reflow ），负责各元素尺寸、位置的计算
>- 绘制 render 树（ paint ），绘制页面像素信息
>- 浏览器会将各层的信息发送给 GPU，GPU 会将各层合成（ composite ），显示在屏幕上
>

### 14.4 http缓存中，强缓存和协商缓存的区别？

>​               缓存可以减少冗余的数据传输。节省了网络带宽，从而更快的加载页面。也可以降低了服务器的要求，从而服务器更快的响应
>
> 协商缓存:  客户端向服务器端发出请求，服务端会检测是否有对应的标识，如果没有对应的标识，服务器端会返回一个对应的标识给客户端，客户端下次再次请求的时候，把该标识带过去，然后服务器端会验证该标识，如果验证通过了，则会响应304，告诉浏览器读取缓存。如果标识没有通过，则返回请求的资源。直白说就是客户端和服务器商量那些东西进行缓存.
>
>协商缓存的标识有2种：**ETag/if-None-Match 和 Last-Modified/if-Modify-Since**
>
>强制缓存: 浏览器在加载资源的时候，会先根据本地缓存资源的header中的信息(Expires 和 Cache-Control)来判断是否需要强制缓存。如果命中的话，则会直接使用缓存中的资源。否则的话，会继续向服务器发送请求。直白来说就是我不管,我要全部缓存.

### 14.5 常用的网络状态码?以及出现状态如何解决

>​       HTTP状态码（英语：HTTP Status Code），用以表示网页服务器超文本传输协议响应状态的3位数字代码,简单来讲，`http`状态码的作用是服务器告诉客户端当前请求响应的状态，通过状态码就能判断和分析服务器的运行状态
>
>​     状态码中
>
>- 1 表示消息
>- 2 表示成功
>  - 200（成功）：请求已成功，请求所希望的响应头或数据体将随此响应返回
>- 3 表示重定向
>  - 300（多种选择）：针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择
>  - 301（永久移动）：请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置
>  - 302（临时移动）： 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求
>  - 303（查看其他位置）：请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码
>
>  - 305 （使用代理）： 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理
>  - 307 （临时重定向）： 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求
>- 4 表示请求错误
>  - 400（错误请求）： 服务器不理解请求的语法
>  - 401（未授权）： 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。
>  - 403（禁止）： 服务器拒绝请求
>  - 404（未找到）： 服务器找不到请求的网页
>  - 405（方法禁用）： 禁用请求中指定的方法
>  - 406（不接受）： 无法使用请求的内容特性响应请求的网页
>  - 407（需要代理授权）： 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理
>  - 408（请求超时）： 服务器等候请求时发生超时
>- 5 表示服务器错误
>  - 500（服务器内部错误）：服务器遇到错误，无法完成请求
>  - 501（尚未实施）：服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码
>  - 502（错误网关）： 服务器作为网关或代理，从上游服务器收到无效响应
>  - 503（服务不可用）： 服务器目前无法使用（由于超载或停机维护）
>  - 504（网关超时）： 服务器作为网关或代理，但是没有及时从上游服务器收到请求
>  - 505（HTTP 版本不受支持）： 服务器不支持请求中所用的 HTTP 协议版本
>
>重点
>
>- 100：客户端在发送POST数据给服务器前，征询服务器情况，看服务器是否处理POST的数据，如果不处理，客户端则不上传POST数据，如果处理，则POST上传数据。常用于POST大数据传输
>
>- 206：一般用来做断点续传，或者是视频文件等大文件的加载
>
>- 301：永久重定向会缓存。新域名替换旧域名，旧的域名不再使用时，用户访问旧域名时用301就重定向到新的域名
>
>- 302：临时重定向不会缓存，常用 于未登陆的用户访问用户中心重定向到登录页面
>- 304：协商缓存，告诉客户端有缓存，直接使用缓存中的数据，返回页面的只有头部信息，是没有内容部分
>- 400：参数有误，请求无法被服务器识别
>- 403：告诉客户端进制访问该站点或者资源，如在外网环境下，然后访问只有内网IP才能访问的时候则返回
>- 404：服务器找不到资源时，或者服务器拒绝请求又不想说明理由时
>- 503：服务器停机维护时，主动用503响应请求或 nginx 设置限速，超过限速，会返回503
>
>- 504：网关超时
>

### 14.6 说说对WebSocket的理解？应用场景？

>​       WebSocket，是一种网络传输协议，位于`OSI`模型的应用层。可在单个`TCP`连接上进行全双工通信，能更好的节省服务器资源和带宽并达到实时通迅,客户端和服务器只需要完成一次握手，两者之间就可以创建持久性的连接，并进行双向数据传输
>
>​      ### 他的优点是: 
>
>- 较少的控制开销：数据包头部协议较小，不同于http每次请求需要携带完整的头部
>- 更强的实时性：相对于HTTP请求需要等待客户端发起请求服务端才能响应，延迟明显更少
>- 保持创连接状态：创建通信后，可省略状态信息，不同于HTTP每次请求需要携带身份验证
>- 更好的二进制支持：定义了二进制帧，更好处理二进制内容
>- 支持扩展：用户可以扩展websocket协议、实现部分自定义的子协议
>- 更好的压缩效果：Websocket在适当的扩展支持下，可以沿用之前内容的上下文，在传递类似的数据时，可以显著地提高压缩率
>
>### 应用场景
>
>基于`websocket`的事实通信的特点，其存在的应用场景大概有：
>
>- 弹幕
>- 媒体聊天
>- 协同编辑
>- 基于位置的应用
>- 体育实况更新
>- 股票基金报价实时更新

## 十五、小程序与UNI-APP面试题

### 15.1 小程序的微信支付功能

>
>
>​        在下单时，需要将购买的商品Id，商品数量，以及用户的openId传送到服务器,服务器在接收到商品Id、商品数量、openId后，生成服务期订单数据，同时经过一定的签名算法，向微信支付发送请求，获取预付单信息(prepay_id)，同时将获取的数据再次进行相应规则的签名，向小程序端响应必要的信息,小程序端在获取对应的参数后，调用wx.requestPayment()发起微信支付，同时将获取到的参数传递过去,唤醒支付工作台，进行支付,接下来的一些列操作都是由用户来操作的包括了微信支付密码，指纹等验证，确认支付之后执行鉴权调起支付,在微信后台进行鉴权，微信后台直接返回给前端支付的结果，前端收到返回数据后对支付结果进行展示,微信后台在给前端返回支付的结果后，也会向后台也返回一个支付结果，后台通过这个支付结果来更新订单的状态
>
>- 打开某小程序，点击直接下单
>- wx.login获取用户临时登录凭证code，发送到后端服务器换取openId
>- 在下单时，小程序需要将购买的商品Id，商品数量，以及用户的openId传送到服务器
>- 服务器在接收到商品Id、商品数量、openId后，生成服务期订单数据，同时经过一定的签名算法，向微信支付发送请求，获取预付单信息(prepay_id)，同时将获取的数据再次进行相应规则的签名，向小程序端响应必要的信息
>- 小程序端在获取对应的参数后，调用wx.requestPayment()发起微信支付，唤醒支付工作台，进行支付
>- 接下来的一些列操作都是由用户来操作的包括了微信支付密码，指纹等验证，确认支付之后执行鉴权调起支付
>- 鉴权调起支付：在微信后台进行鉴权，微信后台直接返回给前端支付的结果，前端收到返回数据后对支付结果进行展示
>- 推送支付结果：微信后台在给前端返回支付的结果后，也会向后台也返回一个支付结果，后台通过这个支付结果来更新订单的状态

### 15.2 说说微信小程序的生命周期函数有哪些？

>小程序中，生命周期主要分成了三部分：
>
>- 应用的生命周期
>
>  - 小程序的生命周期函数是在`app.js`里面调用的，通过`App(Object)`函数用来注册一个小程序，指定其小程序的生命周期回调
>
>  - | 生命周期               | 说明                                    |
>    | ---------------------- | --------------------------------------- |
>    | onLaunch               | 小程序初始化完成时触发，全局只触发一次  |
>    | onShow                 | 小程序启动，或从后台进入前台显示时触发  |
>    | onHide                 | 小程序从前台进入后台时触发              |
>    | onError                | 小程序发生脚本错误或 API 调用报错时触发 |
>    | onPageNotFound         | 小程序要打开的页面不存在时触发          |
>    | onUnhandledRejection() | 小程序有未处理的 Promise 拒绝时触发     |
>    | onThemeChange          | 系统切换主题时触发                      |
>
>- 页面的生命周期
>
>  - 页面生命周期函数就是当你每进入/切换到一个新的页面的时候，就会调用的生命周期函数，同样通过`App(Object)`函数用来注册一个页面
>
>  - | 生命周期 | 说明                              | 作用                           |
>    | -------- | --------------------------------- | ------------------------------ |
>    | onLoad   | 生命周期回调—监听页面加载         | 发送请求获取数据               |
>    | onShow   | 生命周期回调—监听页面显示         | 请求数据                       |
>    | onReady  | 生命周期回调—监听页面初次渲染完成 | 获取页面元素（少用）           |
>    | onHide   | 生命周期回调—监听页面隐藏         | 终止任务，如定时器或者播放音乐 |
>    | onUnload | 生命周期回调—监听页面卸载         | 终止任务                       |
>
>- 组件的生命周期
>
>  - 组件的生命周期，指的是组件自身的一些函数，这些函数在特殊的时间点或遇到一些特殊的框架事件时被自动触发，通过`Component(Object)`进行注册组件
>
>  - | 生命周期 | 说明                              |
>    | -------- | --------------------------------- |
>    | created  | 生命周期回调—监听页面加载         |
>    | attached | 生命周期回调—监听页面显示         |
>    | ready    | 生命周期回调—监听页面初次渲染完成 |
>    | moved    | 生命周期回调—监听页面隐藏         |
>    | detached | 生命周期回调—监听页面卸载         |
>    | error    | 每当组件方法抛出错误时执行        |

>
>
>小程序的生命周期执行顺序: 小程序先启动,然后执行页面声明周期,组件生命周期,最后小程序销毁

### 15.3 小程序怎么跟随事件传值

>在 页面标签上通过 绑定 `dataset-key = value` ， 然后绑定点击通过`e.currentTarget.dataset.key` 来获取标签上绑定的值。
>
>```js
><button bindtap="get"  data-name="测试"> 拿到传值</button>
>
>get(e){
>    console.log(e.currentTarget.dataset.name)
>  },
>```



### 15.4 小程序的双向绑定和Vue哪里不一样?

>小程序 直接使用`this.data.key = value` 是 不能更新到视图当中的。
>必须使用 `this.setData({ key ：value })` 来更新值。
>
>

### 15.5小程序怎么实现下拉刷新

>**两种方案**
>**方案 一 ：**
>
>- 通过在 `app.json` 中， 将 `"enablePullDownRefresh": true,` 开启全局下拉刷新。
>- 或者通过在 `组件 .json` ， 将 `"enablePullDownRefresh": true,` 单组件下拉刷新。
>
>**方案二：**
>
>- `scroll-view` ：使用该滚动组件 自定义刷新，通过 `bindscrolltoupper` 属性， 当滚动到顶部/左边，会触发 `scrolltoupper`事件，所以我们可以利用这个属性，来实现下拉刷新功能。
>

### 15.6  如何封装小程序请求

>使用promise进行封装wx.request,解决异步回调问题,wx.request有几个重要的参数
>
>- url -- 请求地址
>- method -- 请求方式(Get/Post,这里我们只封装这2个请求)
>- data -- 请求的参数
>- success -- 接口调用成功的回调函数
>- fail -- 接口调用失败的回调函数
>
>接下来用promise进行封装,同时将加载中也封装进去,
>
>```js
>  /**
>       request.js
>     * 封装一个Promise风格的通用请求
>     * url - 请求地址
>     * option - 包含请求方式、请求参数的配置对象
> */
> var app = getApp(); //引入全局app.js，我们可以在globalData中定义一些公用的数据，比如baseUrl、token
> import Toast from '/@vant/weapp/toast/toast';//引入vant插件，用于提示错误
> const request = function(url,options){
>   wx.showLoading({
>    title: '请求中，请耐心等待..'
>  });
>     return new Promise((resolve,reject)=>{
>         wx.request({
>             url:app.globalData.baseUrl+url,
>             method:options.method,
>             data:options.method=="GET"?options.data:JSON.stringify(options.data),
>             // header这里根据业务情况自行选择需要还是不需要
>             header:{
>                 'Authorization':'Bearer '+app.globalData.token
>             },
>             success: (res) => {
>                if (res.data.code == 500) {
>                  Toast(res.data.msg);
>                  reject(res.data.msg)
>                } else {
>                  resolve(res)
>                }
>              },
>              fail: (err) => {
>                reject(err)
>              },
>              complete:() => {
>              
>                  wx.hideLoading()
>              }
>         })
>     })
> }
>    
>
>   module.exports = {
>       //封装get方法
>       get(url,data){
>           return request(url,{
>               method:"GET",
>               data
>           })
>       }
>       //封装post方法
>       post(url,data){
>           return request(url,{
>               method:"POST",
>               data
>           })
>       }
>   }
>
>```



### 15.7 说说提高微信小程序的应用速度的手段有哪些？

>提高小程序的应用速度可以从加载、渲染两个纬度进行切入
>
>**小程序启动加载性能**：
>
>- 控制代码包的大小
>- 分包加载
>- 首屏体验（预请求，利用缓存，避免白屏，及时反馈
>
>**小程序渲染性能**：
>
>- 避免不当的使用setData
>- 使用自定义组件

### 15.8 说一说小程序的分包

>​        我们小程序分包是吧tabr页面和登录已经主页面全部划分主包中,其他的放置在分包
>
>​         先修改菜单栏的目录路径,主包放在pages下面,在pages文件夹下面创建文件
>
>​         分包单独创建一个文件夹,文件夹下面在床架pages文件夹,包含分包中的文件内容
>
>接着,去修改app.json文件,在app.json文件中新增subPackages属性,他是数组情况,然后在写一个对象,里面包含root,和pages两个属性,root指的是分包的文件夹名称,pages指文件路径
>
>​     其中小程序整个体积不能大于20m,分包体积不能大于2m

### 15.9 说说微信小程序的登录流程？

>- 通过 wx.login() 获取到用户的code判断用户是否授权读取用户信息，调用wx.getUserInfo 读取用户数据
>- 由于小程序后台授权域名无法授权微信的域名，所以需要自身后端调用微信服务器获取用户信息
>- 通过 wx.request() 方法请求业务方服务器，后端把 appid , appsecret 和 code 一起发送到微信服务器。 appid 和 appsecret 都是微信提供的，可以在管理员后台找到
>- 微信服务器返回了 openid 及本次登录的会话密钥 session_key
>- 后端从数据库中查找 openid ，如果没有查到记录，说明该用户没有注册，如果有记录，则继续往下走
>- session_key 是对用户数据进行加密签名的密钥。为了自身应用安全，session_key 不应该在网络上传输
>- 然后生成 session并返回给小程序
>- 小程序把 session 存到 storage 里面
>- 下次请求时，先从 storage 里面读取，然后带给服务端
>- 服务端对比 session 对应的记录，然后校验有效期

### 15.10 说说微信小程序的发布流程？

>关于发布的流程，主要分成了三个部分：
>
>- 上传代码
>- 提交审核
>- 发布版本
>
>其中上传代码在微信编译器中点击上传按钮,然后就可以填写版本信息,然后点击上传，编译器则会提示上传代码成功.代码上传完毕，就可以登陆微信公众号的官网首页，点击【开发管理】，查看应用详情.然后提交审核,如果是第一次提交,需要填写审核信息.当审核通过之后，即可提交发布.

### 15.11 小程序什么时候会主动销毁？

>小程序在进入后台之后，客户端会帮我们在一定时间内维持我们的一个状态，超过五分钟后，会被微信主动销毁.
>**官方也没有明确说明 什么时候销毁， 在不同机型表现也不一样，**
>2019年开发时：时间官方文档没有说明，但是经过询问一般指5分钟内
>2020年开发时：时间官方文档没有说明，实测安卓没有固定时间，内存足够情况下，有时候一天了还在，有时候几分钟就没了



### 15.16小程序的appid,openid,unionid的区别

>appid: 某个应用的单独标识
>
>openid: 每一个应用下面每一个用户下都有一个唯一的openid,用来标识此用户在此应用下面的身份标识
>
>Unionid: 同一个主题下,不同应用他们之间确定唯一身份的标识就是unionid

### 15.17 说说微信小程序中路由跳转的方式有哪些？区别？

>- `wx.navigateTo()` : 保留当前页面，跳转到应用内的某个页面。但是不能跳到 `tabbar` 页面
>- `wx.redirectTo()` : 关闭当前页面，跳转到应用内的某个页面。但是不允许跳转到 `tabbar` 页面
>- `wx.switchTab()` : 跳转到 `TabBar` 页面，并关闭其他所有非 `tabBar` 页面
>- `wx.navigateBack()` : 关闭当前页面，返回上一页面或多级页面。可通过 `getCurrentPages()` 获取当前的页面栈，决定需要返回几层
>- `wx.reLaunch()` : 关闭所有页面，打开到应用的某个页面。

### 15.18 微信小程序如何调用摄像头、二维码、获取手机号以及具体代码?

>- 微信小程序调用摄像头需要使用 wx.chooseImage 和 wx.chooseVideo API，调用二维码需要使用 wx.scanCode API，获取手机号需要使用 wx.login 和 wx.getUserInfo API，其中在获取手机号时需要用户授权才能获取。
>
>- 调用摄像头：
>
>  ```javascript
>  wx.chooseImage({
>    count: 1,
>    sizeType: ['original', 'compressed'],
>    sourceType: ['album', 'camera'],
>    success: function (res) {
>      var tempFilePaths = res.tempFilePaths
>      // TODO: 处理图片
>    }
>  })
>  
>  ```
>
>  ```javascript
>  wx.chooseVideo({
>    sourceType: ['album', 'camera'],
>    maxDuration: 60,
>    camera: 'back',
>    success: function (res) {
>      var tempFilePath = res.tempFilePath
>      // TODO: 处理视频
>    }
>  })
>  
>  ```
>
>- 调用二维码：
>
>  ```javascript
>  wx.scanCode({
>    success: function (res) {
>      var result = res.result
>      // TODO: 处理扫描结果
>    }
>  })
>  
>  ```
>
>- 获取手机号：
>
>  ```javascript
>  wx.login({
>    success: function (res) {
>      if (res.code) {
>        wx.getUserInfo({
>          success: function (res) {
>            var encryptedData = res.encryptedData
>            var iv = res.iv
>            // TODO: 解密 encryptedData 获取手机号
>          }
>        })
>      }
>    }
>  })
>  ```
>
>  在获取手机号时需要用户授权才能获取，可以在 `app.json 文件中`配置 `"requiredUserInfo" `来提醒用户授权。具体使用方式可以参考微信小程序官方文档和示例代码。

### 15.19 小程序有哪些传递数据的方法

>**1. 使用全局变量**
>
>- 在 `app.js` 中的 `this.globalData = { }` 中放入要存储的数据。
>- 在 `组件.js` 中， 头部 引入 `const app = getApp();` 获取到全局变量
>- 直接使用 `app.globalData.key` 来进行赋值和获取值。
>
>**2. 使用 路由**
>
>- `wx.navigateTo` 和 `wx.redirectTo` 时，可以通过在 `url` 后 拼接 + 变量， 然后在 `目标页面` 通过在 `onLoad` 周期中，通过参数来获取传递过来的值。
>
>**3. 使用本地缓存**

### 15.20 说一说小程序为什么不能获取dom元素?

>因为小程序将视图层和逻辑层是分开的，双线程同时运行，视图层的界面使用 `WebView` 进行渲染，逻辑层运行在 `JSCore` 中
>
>两者交流需要借鉴第三方服务器,所以没办法获取dom元素

### 15.21uniapp通过什么方式进行跨度兼容



>通过条件编译的方式实现跨度的兼容，条件语法 #ifdef  哪个C端    #endif  也可以通过#ifndef来排除哪个端 
>
>条件编译可以在逻辑 样式  视图 配置文件中使用
>
>写法：以 #ifdef *或* #ifndef 加 *%PLATFORM%* 开头，以 #endif 结尾。
>
>- \#ifdef：if defined **仅在** 某平台存在
>- \#ifndef：if not defined **除了** 某平台均存在
>- %PLATFORM%：平台名称

### 15.22 uniapp优缺点

>#### 优点:
>
>​	a. 一套代码可以生成多端
>​	b. 学习成本低,语法是vue的,组件是小程序的
>​	c. 拓展能力强
>​	d. 使用HBuilderX开发,支持vue语法
>​	e. 突破了系统对H5调用原生能力的限制
>
>### 缺点:
>
>​	a. 问世时间短,很多地方不完善
>​	b. 社区不大
>​	c. 官方对问题的反馈不及时
>​	d. 在Android平台上比微信小程序和iOS差
>​	e. 文件命名受限

### 15.23  vue , 微信小程序 , uni-app属性的绑定

>vue和uni-app动态绑定一个变量的值为元素的某个属性的时候，会在属性前面加上冒号":";
>小程序绑定某个变量的值为元素属性时，会用两个大括号{{}}括起来，如果不加括号，为被认为是字符串

### 15.24 说一说jQuery、vue、小程序、uni-app中的本地数据存储和接收有什么不同

>```
>jQuery：
>	存：$.cookie('key','value')
>	取：$.cookie('key')
>
>	vue：
>	存储：localstorage.setItem（‘key’，‘value’）
>	接收：localstorage.getItem（‘key’）
>
>	微信小程序：
>	存储：通过wx.setStorage/wx.setStorageSync写数据到缓存
>	接收：通过wx.getStorage/wx.getStorageSync读取本地缓存，
>
>	uni-app：
>	存储：uni.setStorage({key:“属性名”，data:“值”}) //异步 
>		uni.setStorageSync(KEY,DATA) //同步
>	接收：uni.getStorage({key:“属性名”,success(res){res.data}}) //异步
>		uni.getStorageSync(KEY) //同步
>	移除：uni.removeStorage(OBJECT) //从本地缓存中异步移除指定 key。
>		uni.removeStorageSync(KEY) //从本地缓存中同步移除指定 key。
>	清除：uni.clearStorage() //清理本地数据缓存。
>		uni.clearStorageSync() //同步清理本地数据缓存。
>```

### 15.25 uniapp的生命周期

>界面和应用的生命周期采用的绝大多数是小程序的生命周期
>组件的生命周期采用的是vue的生命周期
>
>一、应用的生命周期
>1.onLaunch——当uni-app 初始化完成时触发（全局只触发一次）
>
>2.onShow——当 uni-app 启动，或从后台进入前台显示
>
>3.onHide——当 uni-app 从前台进入后台
>
>4.onError——当 uni-app 报错时触发
>
>5.onUniNViewMessage——对 nvue 页面发送的数据进行监听，可参考 nvue 向 vue 通讯
>
>6.onUnhandledRejection——对未处理的 Promise 拒绝事件监听函数（2.8.1+）
>
>7.onPageNotFound——页面不存在监听函数
>
>8.onThemeChange——监听系统主题变化 
>
>二、页面的生命周期
>1.onInit——监听页面初始化，其参数同 onLoad 参数，为上个页面传递的数据，参数类型为 Object（用于页面传参），触发时机早于 onLoad
>
>2.onLoad——监听页面加载，其参数为上个页面传递的数据，参数类型为 Object（用于页面传参），参考示例
>
>3.onShow——监听页面显示。页面每次出现在屏幕上都触发，包括从下级页面点返回露出当前页面
>
>4.onReady——监听页面初次渲染完成。注意如果渲染速度快，会在页面进入动画完成前触发
>
>5.onHide——监听页面隐藏
>
>6.onUnload——监听页面卸载
>
>7.onResize——监听窗口尺寸变化
>三、组件的生命周期
>uni-app 组件支持的生命周期，与vue标准组件的生命周期相同
>
>1.beforeCreate——在实例初始化之后被调用。
>
> 2.created——在实例创建完成后被立即调用。
>
>3.beforeMount——在挂载开始之前被调用。
>
>4.mounted——挂载到实例上去之后调用。详见 注意：此处并不能确定子组件被全部挂载，如果需要子组件完全挂载之后在执行操作可以使用$nextTickVue官方文档
>
>5.beforeUpdate——数据更新时调用，发生在虚拟 DOM 打补丁之前。
>
>6.updated——由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。
>
>7.beforeDestroy——实例销毁之前调用。在这一步，实例仍然完全可用。
>
>8.destroyed——Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。

### 15.26 在 Uniapp 中，如何实现路由跳转

>​        Uniapp 提供了一套路由跳转的 API，包括 uni.navigateTo、uni.redirectTo、uni.reLaunch 和 uni.switchTab 等。开发者可以根据不同的需求选择不同的 API 实现路由跳转

### 15.27 uni-app全局变量怎么定义，怎么获取

>在app.js中设置globalData设置，在需要的地方的js文件
>
>let app=getApp()
>
>app.globalData.数据

### 15.28uniapp上传文件时使用的api

>```
>uni.uploadFile({
>   		url: '要上传的地址',
>       		fileType:'image',
>        		filePath:'图片路径',
>        		name:'文件对应的key',
>        		success: function(res){
>			console.log(res)
>		},
>    })
>```
>
>

### 15.29 关于uniapp项目中页面之间传递数据的三种方式

>1. **利用url传参进行通讯**
>2. **uni.$emit()和uni.$on() 进行通讯**
>3.  使用 EventBus 进行通讯
>4.  **利用“全局变量”进行通讯**

### 15.30 uniapp中uni.request封装

>本质上和小程序封装一样,可以用promise进行封装
>
>```js
>const request = (config) => {
>	// 处理 apiUrl
>	config.url = '你的链接服务器地址' + config.url;
>	if(!config.data){
>		config.data = {};
>	}
>	let promise = new Promise(function(resolve, reject) {
>		uni.request(config).then(responses => {
>			// 异常
>			if (responses[0]) {
>				reject({message : "网络超时"});
>			} else {
>				let response = responses[1].data; 
>				resolve(response);
>			}
>		}).catch(error => {
>			reject(error);
>		})
>	})
>	return promise;
>};
>
>export default request;
>```
>
>

### 15.31 uniapp的打包和上线

>​         对于小程序端,使用 HBuiderX 进行打包，此时会自动打开“微信开发者工具”,点击“微信开发者工具”，右上角“上传”,接下来的步骤就和微信上传一模一样
>
>​        对于H5,使用 HBuiderX 进行打包,区分好测试环境和线上环境, 在本地运行解决 **跨域** 问题 `manigest.json`中添加h5对象,配置proxy解决跨域问题,然后将打包好的静态资源放到服务器上即可！ 静态资源的位置：项目根目录下的 `unpackage` -> `dist` -> `build` -> `h5`
>
>```
>{
>    ...
>    "h5": {
>        "devServer": {
>            "proxy": {
>                "/xxx" : {
>                    "target" : "接口地址",
>                    "changeOrigin" : true,
>                    "secure" : false,
>                    "pathRewrite" : {
>                        "^/xxx" : "/xxx"
>                    }
>                }
>                // 注意：多后台人员开发接口，可以配置多个同时和多后台人员联调
>            }
>        }
>    }
>    ...
>}
>```
>
>​       对于安卓和ios选择安心打包,配置证书,进行打包编译,最后在应用商城填写信息进行上线

## 十六、操作系统及浏览器安全问题

### 16.1 有哪些可能引起前端安全的问题?

>- **跨站脚本** (Cross-Site Scripting, XSS): ⼀种代码注⼊⽅式, 为了与 CSS 区分所以被称作 XSS。早期常⻅于⽹络论坛, 起因是⽹站没有对⽤户的输⼊进⾏严格的限制, 使得攻击者可以将脚本上传到帖⼦让其他⼈浏览到有恶意脚本的⻚⾯, 其注⼊⽅式很简单包括但不限于 JavaScript / CSS / Flash 等；
>- **iframe的滥⽤**: iframe中的内容是由第三⽅来提供的，默认情况下他们不受控制，他们可以在iframe中运⾏JavaScirpt脚本、Flash插件、弹出对话框等等，这可能会破坏前端⽤户体验；
>- **跨站点请求伪造**（Cross-Site Request Forgeries，CSRF）: 指攻击者通过设置好的陷阱，强制对已完成认证的⽤户进⾏⾮预期的个⼈信息或设定信息等某些状态更新，属于被动攻击
>- **恶意第三⽅库**: ⽆论是后端服务器应⽤还是前端应⽤开发，绝⼤多数时候都是在借助开发框架和各种类库进⾏快速开发，⼀旦第三⽅库被植⼊恶意代码很容易引起安全问题。

### 16.2 网络劫持有哪几种，如何防范？

>⽹络劫持分为两种:
>
>（1）**DNS劫持**: (输⼊京东被强制跳转到淘宝这就属于dns劫持)
>
>- DNS强制解析: 通过修改运营商的本地DNS记录，来引导⽤户流量到缓存服务器
>- 302跳转的⽅式: 通过监控⽹络出⼝的流量，分析判断哪些内容是可以进⾏劫持处理的,再对劫持的内存发起302跳转的回复，引导⽤户获取内容
>
>（2）**HTTP劫持**: (访问⾕歌但是⼀直有贪玩蓝⽉的⼴告),由于http明⽂传输,运营商会修改你的http响应内容(即加⼴告)
>
>DNS劫持由于涉嫌违法，已经被监管起来，现在很少会有DNS劫持，⽽http劫持依然⾮常盛⾏，最有效的办法就是全站HTTPS，将HTTP加密，这使得运营商⽆法获取明⽂，就⽆法劫持你的响应内容。

### 16.3 进程与线程的概念

>从本质上说，进程和线程都是 CPU 工作时间片的一个描述：
>
>- 进程描述了 CPU 在运行指令及加载和保存上下文所需的时间，放在应用上来说就代表了一个程序。
>- 线程是进程中的更小单位，描述了执行一段指令所需的时间。
>
>**进程是资源分配的最小单位，线程是CPU调度的最小单位。**

### 16.4 进程和线程的区别

>- 进程可以看做独立应用，线程不能
>- **资源**：进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）；线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）。
>- **通信方面**：线程间可以通过直接共享同一进程中的资源，而进程通信需要借助 进程间通信。
>- **调度**：进程切换比线程切换的开销要大。线程是CPU调度的基本单位，线程的切换不会引起进程切换，但某个进程中的线程切换到另一个进程中的线程时，会引起进程切换。
>- **系统开销**：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存、I/O 等，其开销远大于创建或撤销线程时的开销。同理，在进行进程切换时，涉及当前执行进程 CPU 环境还有各种各样状态的保存及新调度进程状态的设置，而线程切换时只需保存和设置少量寄存器内容，开销较小。

### 16.5 如何解决跨越问题

> ### **CORS**
>
> CORS需要浏览器和服务器同时支持，整个CORS过程都是浏览器完成的，无需用户参与。因此实现**CORS的关键就是服务器，只要服务器实现了CORS请求**，就可以跨源通信了。
>
> ### **JSONP**
>
> **jsonp**的原理就是利用`<script>`标签没有跨域限制，通过`<script>`标签src属性，发送带有callback参数的GET请求，服务端将接口返回数据拼凑到callback函数中，返回给浏览器，浏览器解析执行，从而前端拿到callback函数返回的数据
>
> **优点**
>
> - 实现简单
> - 兼容性好, 可用于解决主流浏览器的跨域数据访问的问题。
>
> **缺点**
>
> - 只支持 GET 请求 ( 因为 
> - 存在被 XSS 攻击的可能, 缺乏安全性保证
> - 需要服务端配合改造
>
> ### **postMessage**
>
> postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：
>
> - 页面和其打开的新窗口的数据传递
> - 多窗口之间消息传递
> - 页面与嵌套的iframe消息传递
> - 上面三个场景的跨域数据传递
>
> 用法：postMessage(data,origin)方法接受两个参数：
>
> - **data**： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。
> - **origin**： 协议+主机+端口号，也可以设置为"*"，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为"/"。
>
> ### 
>
> ### **Node中间件代理(proxy正向代理)(两次跨域)**
>
> 实现原理：**同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。** 代理服务器，需要做以下几个步骤：
>
> - 接受客户端请求 。
> - 将请求 转发给服务器。
> - 拿到服务器 响应 数据。
>
> ### **nginx反向代理**
>
> 实现原理类似于Node中间件代理，需要你搭建一个中转nginx服务器，用于转发请求。
>
> 使用nginx反向代理实现跨域，是最简单的跨域方式。只需要修改nginx的配置即可解决跨域问题，支持所有浏览器，支持session，不需要修改任何代码，并且不会影响服务器性能。
>
> 实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。

### 16.6 正向代理和反向代理的区别

>- **正向代理：**
>
>客户端想获得一个服务器的数据，但是因为种种原因无法直接获取。于是客户端设置了一个代理服务器，并且指定目标服务器，之后代理服务器向目标服务器转交请求并将获得的内容发送给客户端。这样本质上起到了对真实服务器隐藏真实客户端的目的。实现正向代理需要修改客户端，比如修改浏览器配置。
>
>- **反向代理：**
>
>服务器为了能够将工作负载分不到多个服务器来提高网站性能 (负载均衡)等目的，当其受到请求后，会首先根据转发规则来确定请求应该被转发到哪个服务器上，然后将请求转发到对应的真实服务器上。这样本质上起到了对客户端隐藏真实服务器的作用。 一般使用反向代理后，需要通过修改 DNS 让域名解析到代理服务器 IP，这时浏览器无法察觉到真正服务器的存在，当然也就不需要修改配置了。

### 16.7 token过期后，页面如何实现无感刷新?

>**什么是无感刷新**
>
>后台返回的token是有时效性的，时间到了，你在交互后台的时候，后台会判断你的token是否过期（安全需要），如果过期了就会逼迫你重新登陆！
>
>**token无感刷新其本质是为了优化用户体验,当token过期时不需要用户跳回登录页重新登录,而是当token失效时,进行拦截,发送刷新token的ajax,获取最新的token进行覆盖,让用户感受不到token已经过期**
>
>**实现无感刷新**
>
>1、后端返回过期时间，前端判断token过期时间,去调用刷新token接口。
>
>缺点：需要后端额外提供一个Token过期时间的字段；使用了本地时间判断，若本地时间篡改，特别是本地时间比服务器时间慢时，拦截会失败。
>
>2、写个定时器，定时刷新Token接口。缺点：浪费资源,消耗性能,不建议采用。
>
>3、在响应拦截器中拦截，判断Token 返回过期后，调用刷新token接口。

### 16.8 linux常用的命令

>1）cd : 进入目录。
>
>2）cd . . 回退到上一个目录，直接cd进入默认目录
>
>3）pwd : 显示当前所在的目录路径。
>
>4）ls(ll):  都是列出当前目录中的所有文件，只不过ll(两个ll)列出的内容更为详细。（Mac只有ll） window(只能使用ls)
>
>5）touch : 新建一个文件 如 touch index.js 就会在当前目录下新建一个index.js文件。
>
>6）rm:  删除一个文件, rm index.js 就会把index.js文件删除。
>
>7）mkdir:  新建一个目录,就是新建一个文件夹。
>
>8）rm -r :  删除一个文件夹, rm -r src 删除src目录  !!!!重点 慎用
>
>9）mv 移动文件, mv index.html src。 index.html 是我们要移动的文件, src 是目标文件夹,当然, 这样写,必须保证文件和目标文件夹在同一目录下。
>
>10）reset 重新初始化终端/清屏。
>
>11）clear 清屏。
>
>12）history 查看命令历史。
>
>13）help 帮助。（Mac除外）
>
>14）exit 退出。
>
>15）#表示注释
>
>16) ls: 查看桌面的所有文件
>

### 16.9前端怎么做SEO优化

>**什么是SEO**
>
>SEO(Search Engine Optimization)，即搜索引擎优化。SEO是随着搜索引擎的出现而来的，两者是相互促进，互利共生的关系。SEO的存在就是为了提升网页在搜索引擎自然搜索结果中的收录数量以及排序位置而做的优化行为。而优化的目的就是为了提升网站在搜索引擎中的权重，增加对搜索引擎的友好度，使得用户在访问网站时能排在前面。
>
>**为什么要做SEO**
>
>提高网站的权重，增强搜索引擎友好度，以达到提高排名，增加流量，改善（潜在）用户体验，促进销售的作用。
>
>**前端怎么做SEO优化**
>
>1. 网站结构布局优化: 尽量简单
>   - 控制首页链接数量
>   - 网页层级不要太深
>   - 控制页面大小, 减少HTTP请求, 提高网站的加载速度
>   - 尽量使用语义化标签
>   - 利用浏览器缓存
>
>

## 十七、项目难点与解决方案面试题(必须背过的)



##十八、  pinia和vuex的区别









### 十九、审批流

1. 先确定审批类型

   * 请假

   * 出差

     2. 确定审批流程

        * 请假审批流程
          * 请假人
          * 请假时间
          * 请假原因
          * 审批人--- 上级
          * 审批人 --- 上一级
          * 审批 ....

        ---------------------- 以上信息只有管理员可以去完成

        申请人 ---  申请请假模块

        

        申请人,发起请假

        

        审批状态: 待审批,审批中,  审批通过/审批驳回

        

        

        填写完请假信息,看一下审批的详细信息

        

        

        

        

        

        RBAC

        权限标识: 文件夹名称:按钮功能, user:add

          permission = ['user:add', 'user:update', 'user:delete'......]

        ​    我们在路由前置守卫请求接口的时候,后台同时给我们返回了一个permission数组,这个数组里面包含了我们所有的按钮权限标识集合,我们将他放置在vuex/本地储存中

           我们通过自定义指令,判断当前按钮标识是否包含在permission数组中,存在当前按钮就显示,不存在就隐藏,我们主要通过es6新增的includes进行判断的

        

        页面渲染

        我们使用的是elementui中菜单组件,el-menu进行渲染,在选择第二级和第三级菜单的时候,会先判断一下当前children是否存在,如果存在就行渲染,不存在隐藏

        

        动态路由业务逻辑

        我们主要使用到三个模块,角色管理,用户模块,菜单管理模块

        新增一个用户之前,一定要准备好角色,我们 运维人员,组员/项目成员,项目经理/主管,人事. 新建角色,选择当前角色可以查看的路由和按钮信息

        新建用户时候,将用户和角色关联起来,进行权限关联

        

        动态路由路由表处理

        1. 现在路由表中编写静态路由表,例如: 404,登录,首页,401

        2. 在前置路由守卫中(router,beforeEach),去判断当前用户前往哪里,如果去登录页面,直接放行,不进行路由合并,如果去其他页面,请求接口,获取动态路由,不过我们的动态路由后台帮我们把数据处理好,处理我们想要树形数据,我们将静态路由和动态路由通过router,addRoute进行合并,注册完成路由表.

           

           

           

           

           

        

        

        

        

        

        

        

        

        

        

        

        

        

        

        

        

        

        

        

        

        

        

        

        

        

        

