## 声明响应式状态

ref()和$refs可以获取dom元素 组件实例  和获取子组件的方法   



ref被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 Srefs对象上。如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素，如果用在子组件上，引用就指向该子组件实例。通俗的讲，ref特性就是为元素或子组件赋予一个ID引用,通过this.Srefs.refName来访问元素或子组件的实例
this.$refs介绍
this.Srefs是一个对象，持有当前组件中注册过 ref特性的所有 DOM 元素和子组件实例注意: Srefs只有在组件渲染完成后才填充，在初始渲染的时候不能访问它们，并且它是非响应式的，因此不能用它在模板中做数据绑定
注意: 当ref和v-for一起使用时，获取到的引用将会是一个数组，包含循环数组源

## Props 声明

#### props有两种接收方法：

```
第一种：使用数组的方法

props: ['title', 'likes', 'isPublished', 'commentIds', 'author']
```

```
第二种：使用对象方法
props:{
	props: {
    // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)
    propA: Number,
    // 多个可能的类型
    propB: [String, Number],
    // 必填的字符串
    propC: {
      type: String,
      required: true
    },
    // 带有默认值的数字
    propD: {
      type: Number,
      default: 100
    },
    // 带有默认值的对象
    propE: {
      type: Object,
      // 对象或数组默认值必须从一个工厂函数获取
      default: function () {
        return { message: 'hello' }
      }
    },
    // 自定义验证函数
    propF: {
      validator: function (value) {
        // 这个值必须匹配下列字符串中的一个
        return ['success', 'warning', 'danger'].includes(value)
      }
    }
  }
}
```

## $nextTick异步回调

 $nextTick也叫做异步更新队列⽅法,⽽$nextTick⽅法的主要作⽤就是等待dom元素加载完毕之后才

会执⾏的回调函数,我们经常会在$nextTick⽅法⾥⾯`获取dom元素`



# minxis

minixs:会和组件中的data进行混合

如果mixins和组件有相同命名,组件优先

1.组件

2.minis

总结:

使用方法:概念:公用方法和数据的时候,抽出可以进行混入

1.当mixins中和组件有重复的命名和方法时,最终以组件为准

2.mixins生命周期先执行,组件后执行

3.当两个mixins有重复值的时候,mixins的引入顺序决定值的顺序



`mixins` 选项接受一个 mixin 对象数组。这些 mixin 对象可以像普通的实例对象一样包含实例选项，它们将使用一定的选项合并逻辑与最终的选项进行合并。举例来说，如果你的 mixin 包含了一个 `created` 钩子，而组件自身也有一个，那么这两个函数都会被调用。

Mixin 钩子的调用顺序与提供它们的选项顺序相同，且会在组件自身的钩子前被调用。

#  Plugins 

  插件 (Plugins) 是一种能为 Vue 添加全局功能的工具代码 

 *import* { createApp } *from* 'vue' const app = createApp({}) app.use(myPlugin, {  */\* 可选的选项 \*/* }) 



```vue
import { createApp } from 'vue'

const app = createApp({})

app.use(myPlugin, {
  /* 可选的选项 */
})
```

 一个插件可以是一个拥有 `install()` 方法的对象，也可以直接是一个安装函数本身。安装函数会接收到安装它的[应用实例](https://cn.vuejs.org/api/application.html)和传递给 `app.use()` 的额外选项作为参数： 

```vue
const myPlugin = {
  install(app, options) {
    // 配置此应用
  }
}
```

插件没有严格定义的使用范围，但是插件发挥作用的常见场景主要包括以下几种：

1. 通过 [`app.component()`](https://cn.vuejs.org/api/application.html#app-component) 和 [`app.directive()`](https://cn.vuejs.org/api/application.html#app-directive) 注册一到多个全局组件或自定义指令。
2. 通过 [`app.provide()`](https://cn.vuejs.org/api/application.html#app-provide) 使一个资源[可被注入](https://cn.vuejs.org/guide/components/provide-inject.html)进整个应用。
3. 向 [`app.config.globalProperties`](https://cn.vuejs.org/api/application.html#app-config-globalproperties) 中添加一些全局实例属性或方法
4. 一个可能上述三种都包含了的功能库 (例如 [vue-router](https://github.com/vuejs/vue-router-next))。

# localStorage、sessionStorage的区别

sessionStorage:只在当前会话页面运行关闭当前会话就会数据丢失,消失,内存比较小

localStorage:关闭会话数据不会丢失数据,除非手动清除,不然数据会一直保存, 

sessionStorage:内存比较小,localStorage:比sessionStorage内存大