[TOC]

[TOC]



#### 原生JS

1、通过ID获取；

2、通过name属性获取；

3、通过标签名获取；

4、通过类名获取；

5、获取body

6、获取img/li

```javascript
//通过id获取
<div id = 'id'></div>
document.getElementById('id');

//通过name属性获取
<div name = 'name'></div>
var domByName = document.getElementsByName('name');

//通过标签名获取；
<div></div>
document.getElementsByTagName('div');

//通过类名获取；
<span class = 'className'></span>
document.getElementsByClassName('className');

//获取body
document.getElementsByTagName("body")[0]

//获取img/li
document.getElementsByTagName("img")
document.getElementsByTagName("li")

```

7.Math对象

```javascript
Math.abs(数字); 取绝对值

Math.ceil(数字); 向上取整

Math.floor(数字); 向下取整

Math.round(数字); 四舍五入

Math.max(数字,数字,数字,数字,..); 求最大值

Math.min(数字,数字,数字,数字,..); 求最小值

Math.pow(x,y); x的y次幂

Math.sqrt(数字); 开平方根

Math.random(); 随机生成[0-1)随机小数

// 获取1-100 的随机数
Math.random()*100

new Date();//日期对象的创建 

```

8.日期对象

```javascript
var date = new Date();  //创建一个日期对象
date .getYear(); //获取当前年份(2位)

date .getFullYear(); //获取完整的年份(4位)

date .getMonth(); //获取当前月份(0-11,0代表1月)

date .getDate(); //获取当前日(1-31)

date .getDay(); //获取当前星期X(0-6,0代表星期天)

date .getTime(); //获取当前时间(从1970.1.1开始的毫秒数)

date .getHours(); //获取当前小时数(0-23)

date .getMinutes(); //获取当前分钟数(0-59)

date .getSeconds(); //获取当前秒数(0-59)

date .getMilliseconds(); //获取当前毫秒数(0-999)

date .toLocaleDateString(); //获取当前日期

var mytime=date .toLocaleTimeString(); //获取当前时间

date .toLocaleString( ); //获取日期与时间

```



### JS绑定事件

---

1.Dom常用事件对象：
    onclick     绑定点击事件
    onfocus     获取焦点事件
    onblur      失去焦点事件
    onchange    文本域变化事件

2.input框获取焦点失去焦点模型(输入提示信息)

```javascript
//点击事件
// 通过id获取
// var 变量名 = document.getElementById('id');
// 绑定点击事件 变量名 = onclick = function (){}

//input框获取焦点失去焦点模型(输入提示信息)
// <input type="text" value="输入账号" id="d1">
//    value 就是获取的input中的内容
// let 变量名 = document.getElementById('d1').value 

```



### JQuery

---

1.创建元素 类如 $("<p></p>")

2.获取元素里面的内容 : html()  识别标签    text() 不识别标签

3.获取文本域和文本框的内容  val()

4.添加到父元素内部的前面  父元素.prepend('子元素')     添加到父元素内部的后面   父元素.append('子元素')

5.事件 ： click 点击    blur 失去焦点  focus 获取焦点  mouseover 鼠标滑过   mouseout 鼠标离开    Keyup  键盘弹起

6.$("元素").eq(index) 获取的元素集合里面下标为index的元素

7.index() 获取指定元素的下标

8.获取父元素 parent() 亲爹

9.获取祖先元素 parents("指定祖先")

10.获取子元素节点 children() 亲儿子 （可以指定哪个亲儿子）

11.获取后代节点 find("指定后代") 子子孙孙都可以获取到

12.获取所有的兄弟元素 siblings() 除自己以外的兄弟元素

13.forEach循环遍历数组

14.filter过滤数组

15.trim去除首尾两端的空格

16.设置元素样式 $("元素").css("属性名","属性值")

17.获取元素样式 $("元素").css("属性名")

18. 给元素添加指定类名 $("元素").addClass("类名")
19. 删除元素指定类名 $("元素").removeClass("类名")
20. 切换类名 $("元素").toggleClass("类名") 
21. 判断元素是否有指定类名 $("元素").hasClass("类名")
22. 获取元素的固有属性 $("元素").prop("属性名") 
23. 设置元素的固有属性 $("元素").prop("属性名","属性值")
24. 获取元素的自定义属性 $("元素").attr("属性名")
25. 设置元素的自定义属性 $("元素").attr("属性名","属性值")
26. test() 验证内容是否符合正则规则
27. localStorage.setItem() 数据存储本地
28. localStorage.getItem() 获取本地数据
29. JSON.stringify() 数组转字符串
30. JSON.parse() 字符串解析为数组

### let  const

---

   没有变量提升  
   同一作用域内，无法对同一个变量/常量进行重复声明。
     const 块级作用域  可以修改引用数据类型不能修改基础数据类型

### **什么是作用域链** 

---

  函数执行时，现在内部找这个变量如果找不到向上层找直到找到全局作用域或者undefined

  嵌套关系的作用域串联起来形成了作用域链

  作用:作用域链本质上是底层的**变量的查找机制**

- 函数被执行时，会优先查找当前函数作用域中的变量
- 如果当前作用域中查找不到会逐级向上查找父级作用域直到全局作用域

### **作用域**

---

   1.指一个变量的作用范围

   2.作用域**规定了**变量能够被访问的 ‘范围’**，离开了这个范围变量便不能被访问

   3.在ES6之前，只有全局作用域和函数作用域，在ES6中，新增了块级作用域

 分为：

- 局部作用域
  - 函数作用域 ---在函数里
  - 块级作用域  let/const ---{}  
- 全局作用域    ---整个script标签里



### **结构赋值**

---

​    数组：解构时不能用字符串，通过下标来结构
​    对象：按照属性来解构，可以更换属性名

```javascript
        // 变量的结构赋值
        //   1、数组的结构赋值
        //     1).数组结构赋值的时候，不能使用字符串
        //     2).数组结构通过下标形式结构
        //   2、对象的机构赋值
        //     1).通过属性名进行结构
        //     2).属性重命名

        // 数组的结构
        const F4 = ['蔡徐坤', '鸡哥', '只因你太美']
        const [a, b, c] = F4
        console.log(a);
        console.log(b);
        console.log(c);

        // 对象的结构
        const OBJ = {
            name: '坤哥',
            age: 15
        }
        
        const { name } = OBJ
        const { age: age } = OBJ
        console.log(name);
        console.log(age);
```



### **普通函数和箭头函数的区别**

---

​    普通函数的this 总是指向调用它的对象,如果用作构造函数，它指向创建的对象实例
​    箭头函数全都是匿名函数
​    箭头函数没有this指向和arguments伪数组,箭头函数不具有 prototype 原型对象
​       

### **模板字符串**

---

   用反引号(`)标识它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量
     底层远离还是字符串

### **symbol**

---

​    1.Symbol的值是唯一的,用来解决命名冲突的问题
​    2.Symbol值不能和其他数据进行运算
​    3.Symbol定义的对象属性不能使用for..in循环遍历,但是可以使用Reflect.ownkeys来获取对象的所有键名

### **遍历器**

---

​    是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 teuator 接口，就可以完成遍历操作(即依次处理该数据结构的所有成员

### **promise**

---

1.概念:promise函数是解决异步变成问题产生的,所谓promise,简单说就是一个容器,里面保存着某个未来才会结束的事件(通常是一个异步操作) 的结果。从语法上说,promise 是一个对象,从他可以获取异步操作的消息。promise 提供唯一的 API， 各种一步操作都可以用同样的方法进行处理。
2.实例化promise函数，也是一个容器，既不是同步,也不是异步，里面存放着异步代码
 3.两个参数  resolve: 成功返回  reject; 失败返回  .then()成功返回   .catch()失败的返回**

- (特点)
  1.对象的状态不受外界影响,有三种状态: pending (进行中)、fulfilled (已成功)和 rejected (已失败)
  2.一旦状态改变,就不会再变,任何时候都可以得到这个结果.
  3.`Promise`对象的状态改变，只有两种可能:从 pending 变为 fulfilLed 和从 pending 变为 rejected 。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved (已定型)。如果改变已经发生了，你再对 Promise 对象添加回调函数，也会立即得到这个结果。这与事件(Event)完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。**

### **数组的合并**

---

​    1.可以使用循环加push方法
​    2.可以使用concat方法   语法  let [新数组] = [老数组].concat([另外的一个数组])

```javascript
let arr2 = [数组].concat([数组])
```



### **扩展运算符...**

---

1.概念: ... 扩展运算符能将[数组] 转换为逗号分隔的[参数序列]

### **promise函数**

---

1.实例化promise函数,也是一个容器,既不是同步,也不是异步,里面存放着异步代码

2.两个参数  resolve: 成功返回   reject: 失败返回   .then() 成功返回调用   .catch() 失败返回

```javascript
        //  创建实例化Promise对象
        // const p = new Promise((resolve, reject) => {
        //     定时器
        //     setTimeout(() => {
        //         let result = '我是失败的返回'
        //          //成功返回
        //         // resolve(result)
        //         //失败反悔
        //         reject(result)
        //     })
        // })

        // 实例化的Promise对象调用
        //    //.then成功的回调
        // p.then(res => {
        //     console.log(res, 'res');
        //   //.catch 失败的回调 
        // }).catch(err => {
        //     console.log(err, 'err');
        // })
```



### **ajax**

---

**1.ajax,axios,promise 的底层是根据什么封装的   -- XMLHttpRequest**

**2.promise函数对象中的then方法返回的是promise对象**

**3.then的链式调用**

``` javascript
 // 1.创建对象,创建链接XMLHttpRequest()
    const xhr = XMLHttpRequest()

    // 2.确定请求方法
    xhr.open('get', 'http://www.baidu.com')

    // 3.传递参数,发送请求
    xhr.send()

    // 4.绑定事件,处理响应结果
    xhr.onreadystatechange = function () {
        // 判断 等于4表示成功建立请求连接
        if (xhr.readyState === 4) {
            // 判断响应状态码 200-299
            if (xhr.status >= 200 && xhr.status < 300) {
                // 表示成功
                resolve(xhr.response)
            } else {
                // 如果失败
                reject(xhr.status)
            }

        }
    }
```



### promise.all方法

---

1. .all 同时发起请求,是并发请求

2. 只要一个请求报错,全部返回失败

3. 形参是一个数组,函数调用,全部返回成功,才会返回成功,返回值是一个数组

4. 请求全部成功,则返回的是一个数组

   ```javascript
   语法:
   //Promise.all([]).then(res=>{成功的回调}).catch(err=>{失败的回调})  
   
   ```

   

### promise.race方法

---

1.race 竞速



### promise.finally方法

---

1.不管失败还是成功都会执行的方法

```javascript
语法:
// Promise.all([]).then(res=>{成功的回调}).catch(err=>{失败的回调}).finally()
```

### promise的链式调用

---

1.链式调用

```javascript
    // 链式调用
    // 函数名().then(res => {
    //     return res
    // }).then(val => {
    //     // 这里的val 就是上面第一个.then返回的res
    //     const aa = 函数名().then(res => {
    //         return res
    //     })
    //     // 这里的aa返回的是 Promise对象
    //     return aa

    // }).then(value => {
    //     // 这里的value是上面的aa
    //     getAgen().then(res => {
    //         document.getElementById('p').innerText = value + res
    //     })
    // })

```

### async  awaiw 

---

1.async  awaiw  又叫链式调用的语法糖  

2.async  声明异步函数

3.await  是讲函数改变为同步请求

4.await  并不是改变异步调用函数,只是改变调用顺序

```javascript
    // async function aaa() {
    //  let 自定义名字 = await promise函数()
    //  let 自定义名字 = await promise函数()
    //  let 自定义名字 = await promise函数()
    // }
    // aaa()  //调用aaa
```

### try catch

---

1.一个请求错误则返回的都是error

```javascript
    // async function aaa() {
    //     try {
    //         let 自定义名字 = await promise函数()
    //         console.log(1);
    //         let 自定义名字 = await promise函数()
    //         let 自定义名字 = await promise函数()
    //     } catch (error) {
    //         console.log(error, 'error');
    //     }
    // }
    // aaa()
```



#### 创建对象三种方式

---

###### 1.对象字面量创建对象

```
const o = {
  name:"佩奇"
}
```



###### 2.new Object创建对象

```
const o = new Object({name:"佩奇"})
```

###### 3.利用构造函数创建对象

构造函数:是一种**特殊的函数**，主要用来**创建对象**（初始化对象）

使用场景:

{...}语法允许创建一个对象，继续创建相同类的对象还需要重新写一次，此时可以通过**构造函数**来**创建多个类似的对象**

构造函数在技术上是常规函数，有两个**约定**

- 命名以**大写字母**开头
- 通过**new** 关键字来调用构造函数，可以创建对象

```
 // 对象的创建有3种方式
        // 1.字面量创建  {}
        let obj ={
            name:"佩奇",
            age:12
        }
        let obj1 ={
            name:"zx",
            age:13
        }
        // 2.new Object()
        let newObj =new Object()
        newObj.name = "za"
        newObj['age'] =23
        // 3.构造函数   来创建多个类似的对象
        // - 命名以**大写字母**开头
        // - 通过**new** 关键字来调用构造函数，可以创建对象


            function Person(name,age){
              this.name =name
              this.age = age
              this.sing=function(){
                console.log("我会唱歌")
              }
            }

           let p= new Person('zs',13)
           let p1= new Person('ls',34)
           console.log(p)
           console.log(p1)

           /* 
             构造函数的执行过程
             1.new关键字创建一个空对象
             2.调用构造函数  this指向刚刚new的对象
             3.通过点的方式 给创建的对象添加成员
             4.不写return ，默认返回创建的对象
           
           
           */
```

### 改变this指向

---

1.js中允许改变函数中this的指向，有3个方法可以动态指定普通函数中this的指向

#### 2.call

使用call方法调用函数，同时指定被调用函数中this的指向

```
fun.call(thisArg,arg1,arg2....)
thisArg 在fun函数运行时指定的this值
arg1，arg2 传递的其他参数
返回值就是函数的返回值，因为它就是调用函数
```

使用场景：Object.prototype.toString.call(数据)  检测数据类型

```
 // 使用场景：Object.prototype.toString.call(数据)  检测数据类型

        // typeof 检测数据类型不够精确
        console.log(typeof '123');  //string
        console.log(typeof [])   //object
        console.log(typeof null)  //object

        // Object.prototype.toString.call(数据)  返回的结果是[object xx类型]
        console.log(Object.prototype.toString.call('123'));  //[object String]
        console.log(Object.prototype.toString.call(123))   //[object Number]
        console.log(Object.prototype.toString.call([]))  //[object Array]
        console.log(Object.prototype.toString.call(null))  //[object Null]
```

#### 3.apply

使用apply方法调用函数,同时指定被调用函数中this的值

```
fun.apply(thisArg,[argsArray])
thisArg 在fun函数运行时指定的this值
argsArray 传递的值，必须包含在数组里面
返回值就是函数的返回值，因为它就是调用函数
```

使用场景： 求数组的最大值/最小值

```
// 使用场景： 求数组的最大值/最小值
console.log(Math.max(...[1,2,4]))  //4

// apply 或者call 如果不需要改变this指向 写null
console.log(Math.max.apply(null,[8,45,1,34]))  //45
```

#### 4.bind

bind()方法不会调用函数，但是能改变函数内部this的指向

```
fun.bind(thisArg,arg1,arg2,...)
thisArg 在fun函数运行时指定的this值
arg1，arg2 传递的其他参数
返回由指定的this值和初始化参数改造的原函数拷贝(新函数)
```

代码

```
    <button class="code">发送验证码</button>
    <script>
        const obj = {name:"佩奇"}
        function fun(x,y,z){
            console.log(this)
            return x+y+z
        }

        // fun.bind()  //不会调用函数
        // const fn=fun.bind()
        // console.log(fn)
        // console.log(fn===fun)  //false

        // const fn = fun.bind(obj)  //bind可以改变this指向
        // fn()

        const fn = fun.bind(obj,3,4,5)  //bind可以改变this指向
        console.log(fn())


        // 使用场景 不需要调用函数，但是又想改变函数内部this的指向
        const codeBtn = document.querySelector('.code')
        let flag = true
        codeBtn.addEventListener('click',function(){
            if(flag){
                let i = 5
                this.innerHTML =`05秒后重新获取`
                let timerId = setInterval(function(){
                    // this----window-----codeBtn
                    i--
                    this.innerHTML = `0${i}秒后重新获取`
                    if(i===0){
                        this.innerHTML = `重新获取`
                        clearInterval(timerId)
                        flag = true
                    }
                }.bind(this),1000)
                flag =false
            }
        })

    </script>
```



### new Map对象

##### 1.1.map的方法及属性

 Map对象存有键值对，其中的键可以是任何数据类型。

Map对象记得键的原始插入顺序。

Map对象具有表示映射大小的属性。

##### 1.1 基本的Map() 方法

|  Method   |         Description          |
| :-------: | :--------------------------: |
| new Map() |      创建新的 Map 对象       |
|   set()   |   为 Map 对象添加键和键值    |
|   get()   |    获取 Map 对象中键的值     |
| entries() | 返回 Map 对象中键/值对的数组 |
|  size()   |     返回 Map 对象的长度      |
| delete()  |      删除map某个键值对       |

2.1 使用new Map() 创建map对象

```
//  创建新的map对象
    const map= new Map(
    ['name':'张三'],
    ['title':'985'],
    )
```

2.2 使用set方法 为map对象设置键值对

```
map.set('names','zhangsan')
//采用键值对的方式，其中names为属性名，zhangsan为属性值
```

3.使用has方法 判断是否有该属性名

```
map.has('name') // true
map.has('sex') // false
//如果存在返回true 不存在返回false
```

4.使用get方法 获取map某个属性的值

```
map.get('name') // 张三
```

5.使用delete方法 删除map某个键值对

```
map.delete('name')
```

6.使用clea[r方](https://so.csdn.net/so/search?q=r方&spm=1001.2101.3001.7020)法 清空map的数据,移除所有元素

```
map.clear()
```

7.使用size属性 获取map的长度

```
map.size()
```

8. 对象合并 用Object.assign

 

```
   let obj1={name:'111'}

​    let obj2={names:'111'}

​    Object.assign(obj1,obj2)

​    console.log(obj1);
```



### new set 数组

Set是[es6](https://so.csdn.net/so/search?q=es6&spm=1001.2101.3001.7020)新增的数据结构，**似于数组**，但它的一大特性就是**所有元素都是唯一的**，没有重复的值，我们一般称为集合。

Set本身是一个构造函数，用来生成 Set 数据结构

##### 2、增删改查方法

2.1 添加元素`add`

添加某个值，返回 Set 结构本身，当添加实例中已经存在的元素，set不会进行处理添加

```
1. let list=new Set();
2. list.add(1)
3. list.add(2).add(3).add(3)   *// 2只被添加了一次*
```

2.2 删除元素 `delete`

删除某个值，返回一个布尔值，表示删除是否成功

```javascript
let list=new Set([1,20,30,40])
list.delete(30)      //删除值为30的元素，这里的30并非下标
```

2.3 判断某元素是否存在has

返回一个布尔值，判断该值是否为Set的成员

```
1. let list=new Set([1,2,3,4])
2. list.has(2)*//true*
```

2.4 清除所有元素`clear`

清除所有成员，没有返回值

```javascript
let list=new Set([1,2,3,4])
list.clear()
```

4.1 用于[数组](https://so.csdn.net/so/search?q=数组&spm=1001.2101.3001.7020)去重

```javascript

let arr = [3, 5, 2, 2, 5, 5];
let setArr = new Set(arr)     // 返回set数据结构  Set(3) {3, 5, 2}
 
//方法一   es6的...解构
let unique1 =  [...setArr ];      //去重转数组后  [3,5,2]
 
//方法二  Array.from()解析类数组为数组
let unique2 = Array.from(setArr )   //去重转数组后  [3,5,2]
```

4.2 用于[字符串去重](https://so.csdn.net/so/search?q=字符串去重&spm=1001.2101.3001.7020)

```javascript
let str = "352255";
let unique = [...new Set(str)].join("");     // 352 
```

###  class类

 

```
   // 传统es5中是这样写的

​    function Pina(x,y){

​      this.x=x;

​      this.y=y

​    }

​    Pina.prototype.toString=function(){

​      return '('+ this.x +','+ this.y+')'

​    }

​    var p=new Pina(1,2)

​    console.log(p);



​    // 这是class类的封装class

​    class Pina1{

​      constructor(x,y){

​        this.x=x;

​        this.y=y;

​      }

​      toString () {

​      return '('+this.x+','+this.y+')'

​      }

​    }

​    

​    var p1=new Pina(1,2)

​    console.log(p1);
```

